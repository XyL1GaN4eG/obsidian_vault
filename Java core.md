1. Java Core
2. Frameworks
3. Общие принципы программирования
	1. ООП
		1. Парадигма программирования, при котором программа рассматривается как набор взаимодействующих друг с другом объектов
		2. Основные принципы:
			1. Объект
			2. Класс
			3. Посылка сообщений - единственный способ обмена информацией между объектами
			4. Каждый объект относится к какому-то классу
			5. Поведение объекта определяется его классом
			6. Классы насследуют функциональность от предка
			7. Всё - объект
		3. Основные понятия
			1. Объект (экземпляр)
				1. Базовая единица объектно-ориентированной системы
				2. Отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом
			2. Класс
				1. Способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт)
				2. Можно рассматривать как набор:
					1. Данных
						1. Полей
						2. Атрибутов
						3. Членов класса
					2. Функций для работы с ними
						1. То есть методов
				3. С точки зрения структуры программы, класс является сложным типом данных
			3. Интерфейс
				1. Набор методов класса, доступных для использования
				2. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов
				3. По сути, интерфейс специфицирует класс, четко определяя все возможные действия над ним
		4. Основные парадигмы
			1. Инкапсуляция
				1. Одна из самых спорных парадигм, так как существует несколько трактовок:
					1. Инкапсуляция - это объединение данных и функций, которые управляют этими данными, в единый компонент
					2. Инкапсуляция - это механизм языка, позволяющий ограничить доступ одних компонентов программы к другим
			2. Наследование
				1. Наследование - это механизм языка, который позволяет описывать новый класс на основе существующего
			3. Полиморфизм
				1. Считается главной фишкой ООП
				2. Имеет несколько форм:
					1. Ad Hoc - a.k.a. "полиморфизм говна", a.k.a. специализрованный
						1. Основная идея - перегрузка методов
						2. Противопоставляется параметрическому полиморфизму
					2. Параметрический полиморфизм
						1. Для команды не имеет значения какую сущность ей прислали: для всех классов будет использоваться один код
						2. Возможен только при динамической типизации
					3. Полиморфизм подтипов
						1. Дефолтный полиморфизм для ООП
							1. Возможность использовать одни и те же команды или интерфейсы для разных сущностей/подтипов
							2. Можно понять через паттерн стратегия
			4. Абстракция
				1. Основная идея в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи
				2. Иногда не упоминается в списке парадигм, так как "слишком тривиальная"
			5. Посылка сообщений
			6. Повторное использование
				1. Все предыдущие 5 парадигм должны быть направлены на повторное использование кода
		5. Плюсы:
			1. TODO
		6. Минусы
			1. TODO
	2. SOLID
		1. Single responsibility
			1. Принцип единой ответственности
			2. Делай модули меньше
		2. Open-closed
			1. Принцип открытости-закрытости
			2. Делай модули расширяемыми
				1. Класс должен быть закрыт для изменения, но открыт для расширения
				2. A.k.a. используй абстрактные классы
		3. Liskov Substitution Principle
			1. Принцип подстановки Барбары Лисков
			2. Наследуйся правильно
			3. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
			4. Классы-наследники не должны противоречить базовому классу.
		4. Interface Segregation
			1. Дроби интерфейсы
		5. Dependency Inversion
			1. Используй интерфейсы
			2. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций
			3. Абстракции не должны зависеть от реализации
			4. Реализация должна зависеть от абстракции
4. Паттерны
	1. Стратегия
		1. Поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы