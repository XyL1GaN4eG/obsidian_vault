1. Теория
	1. JSF
		1. Базовые поняти, ключевые особенности, преимущества, недостатки и прочие общие моменты
			1. JSF - фреймворк для разработки веб-приложений
			2. Входит в состав платформы Java EE
			3. Основан на использовании компонентов
			4. Для отображения данных используются JSP/XHTML
			5. Особенности:
				1. JSF четко разделяет бизнес-логику и представление (благодаря MVC)
				2. Приложения построены по шаблону MVC
					1. Model
						1. Managed beans
							1. a.k.a. java классы
							2. Содержат бизнес-логику и передаются юзеру
							3. Указываются аннотации, с помощью которых настраивается поведение
					2. View
						2. Верстка в формате .xhtml
							4. Это удобный формат, так как он 
								1. понятен браузеру
								2. можно легко расширять, добавляя библиотеки
					3. Controller 
						1. Мы его не пишем и не реализуем, он уже имплементирован фреймворком
						2. Реализуется FacesServlet'ом
						3. Нам нужно лишь указывать в верстке action'ы по которым фреймфорк будет понимать что мы хотим получить
			6. Преимущества:
				6. Управление обменном данных на уровне компонентов
				7. Возможность подключать наборы компонентов
				8. Простая работа с событиями на стороне сервера
				9. Доступность реализаций от различных компаний-разработчиков
				10. Расширяемость (достигается при использовании дополнительных наборов компонент)
				11. Широкая поддержка со стороны IDE
			7. Недостатки:
				12. Сложно реализовывать непредусмотренную функциональность из-за высокоуровневости языка
				13. Сложно писать свои компоненты
				14. Сложности с обработкой GET-запросов до JSF 2.0
		2. Структура
			1. ![[JSF MVC.png]]
		3. Создание пользовательского интерфейса в JSF. Иерархия компонентов JSF.
			1. Интерфейс строится из компонентов
			2. Структура представляет из себя дерево представления, с корнем в UIViewRoot
				1. Это ключевой класс в Jakarta Faces
				2. Представляет из себя корневой узел дерева компонентов JSF для конкретной страницы
				3. По сути, этот объект управляет структурой компонентов и состоянием представления на стороне сервера
				4. Роль UIViewRoot в JSF:
					1. Корневой узел
						1. Все компоненты находятся внутри дерева, и, следовательно, являются "потомками" UIViewRoot
					2. Управление представлением
						1. UIViewRoot отвечает за создание, управление и рендеринг всего представления страницы, а так же хранит состояние всех компонентов, включая введенные на клиенте значения, выбранные опции и другую информацию
					3. Участвует во всех фазах жизненного цикла JSF
					4. Один UIViewRoot на страницу
						1. Т.е. для каждой JSF страницы создается один экземпляр UIViewRoot
			3. Компоненты расположены на JSP страницах или jacelet шаблонах (.xhtml)
				1. Все компоненты реализуют интерфейс UIComponent
				2. На компоненты можно ставить:
					1. Слушатели
					2. Валидаторы
					3. Конвертеры
					4. Правила навигации
				3. Благодаря XML верстке можно расширять набор компонентов, используя сторонние библиотеки, либо вообще написав свои
				4. JSF компоненты разделены на две части: 
					1. Базовые компоненты JSF
						1. Не связаны с рендерингом страницы или отображением информации
						2. Используются для преобразования типов и проверки допустимости значений
						3. Примеры:
							1. `f:ajax`
							2. `f:event`
							3. `f:converter`
					2. HTML компоненты JSF
						1. Используются для отрисовки HTML страницы
						2. Примеры:
							1. `h:body`
							2. `h:button`
							3. и в целом все остальное из HTML
			4. Дополнительные библиотеки компонентов
				1. PrimeFaces
				2. IceFaces
				3. RichFaces
				4. и т.д., все примерно одно и то же, те же яйца тока в профиль
		4. Класс FacesServlet - назначение, особенности конфигурации
			1. FacesServlet - главный сервлет в JSF проекте
				1. Первым инициализируется при старте
				2. В дальнейшем управляет жизненным циклом обработки запросов:
					1. Ожидает запросы
					2. Запускает методы по:
						1. валидациям 
						2. слушателям
						3. заполнениям бинов
						4. генерациям ответов
				3. Этот сервлет конфигурируется в файле web.xml
					1. //как и обычный сервлет с классом jakarta.faces.webapp.FacesServlet
			2. ![[JSF-Structure.png]]
			3. 
		5. Фазы JSF
			1. ![[JSF phases.png]]
			2. RestoreView
				1. a.k.a. восстановление представления / формирования представления
				3. Если это первое обращение клиента, то создаются объекты, назначаются слушатели, валидаторы, конверторы, инициализируются языковые настройки все это помещается в FacesContext и отправляется на создание ответа юзеру
				4. Если же FacesContext уже существует (то есть это не первый запрос), то проверяется тип запроса запускаются процессы рендера новых страниц (при GET запросах) и создание/изменение данных (при POST запросах)
				5. JSF Runtime формирует представление (начиная с UIViewRoot):
					1. Создаются объекты компонентов
					2. Назначаются слушатели событий, конверторы, валидаторы
					3. Все элемены представления помещаются в FacesContext
				6. Если это первый запрос пользователя к стрTODO
			3. Apply Request Values
				1. a.k.a. Получение/конвертирование значений запроса и обработка событий
				2. Так как на клиенте все данные находятся в строковом формате, то нужна проверка корректности данных
					1. Для этого вызывается конвертер в соответствии с типом данных значения
				3. При корректной конвертации значение компонента сохраняется в локальной переменной компонента
				4. При некорректной конвертации сообщение об ошибке помещается в FacesContext
					1. JSF пропускает все остальные шаги обработки этого запроса до фазы Формирование ответа
			4. Process validation phase
				1. Проверка значений
					1. Вызываются валидаторы, зарегистрированные для компонентов представлений
				2. Обработка событий 
					1. Если значение компонента не прошло валидацию, то прыгаем на фазу Формирования ответа
			5. Update Model Values
				1. Если данные валидны, то значение компонента обновляется
					1. Если нет, то прыгаем на Формирование ответа
				2. Новое значение присваивается полю объекта компонента
			6. Invoke Application
				1. Фаза вызова приложения
				2. Управление передается слушателям событий
				3. Формирование новых значений компонентов
			7. Render Response Phase
				1. JSF Runtime обновляет представление в соответствии с данными, полученными в предыдущих шагах
					1. Если были получены ошибки на предыдущих шагах, то они собираются в <messages>.
				2. Если это первый запрос к странице, то компоненты помещаются в иерархию представления
				3. Формируется ответ сервера на запрос с помощью managed beans с последующей генерацией html страницы
				4. На стороне клиента происходит обновление страницы
		6. JSF managed beans
			1. A.k.a. управляемые бины
				1. Это классы, содержащие параметры и методы для обработки данных с компонентов
			2. Содержат параметры и методы для обработки данных с компонентов
			3. Используются для обработки событий UI и валидации данных
			4. Жизненным циклом управляет JSF Runtime Environment (JSF RE)
			5. Доступ из JSF-страниц осуществляется с помощью элементов Expression Language (EL)
			6. Конфигурация задается либо в faces-config.xml (в первой версии JSF), либо с помощью аннотаций (доступно со второй версии JSF)
			7. Вместо них могут использоваться CDI-бины, EJB или Spring-бины
		7. Конфигурация managed beans
			1. Аннотации
				1. @ManagedBean
					1. указывает, что класс является управляемым JSF-контейнером
				2. Аннотации для области видимости бина
					1. @RequestScoped
					2. @SessionScoped
					3. @ApplicationScoped
					4. @ViewScoped
					5. @NoneScoped
					6. @CustomeScoped(value="#{someMap}")
						1. Экземпляр создается и сохраняется в какой то мапе
						2. Программист сам управляет областью жизни бина
				3. Через конфиг
					1. ![[JSF Managed-beans-config.png]]
		8. Обработка событий в JSF
			1. ![[JSF Обработка событий.png]]
			2. Реализуется через модель событий, которая связывает пользовательские действия с методами обработчиков в бекенд логике
			3. JSF поддерживает обработку событий через слушателей 
				1. a.k.a. event listeners
			4. Типы событий в JSF
				1. Action Events
					1. Связаны с действиями пользователя, e.g. нажатие кнопки или ссылки
					2. Используются для выполнения бизнес-логики и перехода между страницами
				2. Value Change Events
					1. Вызываются когда пользователь изменяет значение компонента ввода
					2. Используются для обработки данных до их отправки на сервер
					3. Обрабатываются до выполнения действия, что позволяет изменить данные перед отправкой
				3. Lifecycle Events
					1. Обрабатывают события, происходящие на разных этапах жизненного цикла JSF
		9. Конвертеры, валидаторы, создание, назначение, etc
			1. Главная цель конвертации и валидации - это проверка и подготовка данных для обновления значений managed bean компонента
			2. Конвертеры
				1. Используются для преобразования данных компонента в заданный формат (дата, число, etc)
				2. Реализуют интерфейс javax.faces.convert.Converter
				3. Существуют стандартные конвертеры для основных типов данных
					1. javax.faces.
						1. BigDecimal
						2. BigInteger
						3. Boolean
						4. Byte
						5. Character
						6. DateTime
						7. Double
						8. Float
				4. Можно создавать собственные специализированные конвертеры, для этого надо пройти следующие шаги:
					1. Создать класс, реализующий интерфейс Converter
					2. Реализовать метод getAsObject() для преобразования строки в объект
					3. Реализовать метод getAsString()
					4. Зарегистрировать конвертер в faces-config.xml
			3. Валидация
				1. Осуществляется перед обновлением значения компонента на уровне модели
				2. Класс, осуществляющий валидацию, должен реализовывать интерфейс javax.faces.validator.Validator
				3. Существуют стандартные валидаторы для основных типов данных:
				4. Типы валидации:
					1. С помощью встроенных компонентов
						1. DoubleRangeValidator
						2. LongRangeValidator
						3. LengthValidator
						4. validateRegex
					2. На уровне приложения
						1. Пишем сами с помощью методов, которые добавляем в управлемые бины
					3. С помощью проверочных методов серверных объектов
					4. С помощью специализированных компонентов, реализующих интерфейс Validator
		10. Реализация ajax в jsf
			1. Есть два способа реализации: старый и новый:
				1. Через JS API: ![[Arc 2025-02-03 18.50.40.png]]
				2. Через тег `<f:ajax/>`
				3. 
	2. Java EE
		1. IoC и CDI
			1. Нормально реализованы с шестой версии JEE
			2. Для использования надо:
				1. Создать beans.xml
				2. Прописать туда настройку всех созданных бинов
				3. С помощью Inject внедрить зависимость в конструкторы
			3. У бинов существуют скоупы (области видимости), которые помогают контейнеру понимать когда создавать или уничтожать бины
			4. IoC:
				1. Это принцип работы программы, который диктует как писать слабо связанный код
				2. Он говорит, что компонент системы должен быть как можно более изолированным от других
				3. Существует IoC контейнер
					1. Он упрощает работу с компонентами
					2. Автоматизирует написание кода
					3. По максимому берет работу с взаимодействием компонентов на себя
				4. При IoC жизненным циклом компонентов и их взаимодействием управляет контейнер, а не программист
				5. Реализуется с помощью CDI
			5. CDI
				1. Это спецификация Java EE
				2. CDI позволяет снизить (или совсем убрать) зависимость компонента от контейнера
					1. Не требуется дополнительная реализация каких то интерфейсов
					2. Не нужны прямые вызовы API
					3. Реализуется через аннотации
		2. Location Transparency
			1. a.k.a. принцип прозрачного нахождения
			2. ![[JEE Location Transparency.png]]
			3. Благодаря этому принципу можно одинаково обращаться к локальным и удаленным объектам, и клиенту будет не важно где физически находится метод/компонент к которому он обращается, клиент будет думать, что приложение - целостное
			4. В Java это реализовано с помощью JNDI a.k.a. Java Naming and Directory Interface)
				1. Основные понятия JNDI
					1. Naming Service
						1. a.k.a. Служба именования 
						2. Эта система позволяет присваивать имена ресурсам и находить ресурсы по имени
						3. e.g. подключение к базе данных и ресурсу очереди сообщений (типа rabbitmq или apache kafka)
					2. Directory Service
						1. a.k.a. Каталоги
						2. Помимо имени ресурса, предоставляет дополнительную информацию о нем
						3. e.g. LDAP
							1. Lightweight Directory Access Protocol - протокол для каталогов
					3. Context/Контекст
						1. Представляет из себя пространство имен, где ресурсы могут могут быть связаны с именами
						2. Приложение может искать ресурсы начиная с контекста
					4. Binding/Связывание
						1. Процесс, при котором объект (e.g. подключение к БД) связывается с именем в пространстве имен
				2. Компоненты JNDI
					1. InitialContext
						1. Начальная точка для работы с JNDI
						2. Этот объект используется для поиска ресурсов в контексте наименования 
					2. References/Ссылки
						1. JNDI позволяет ссылаться на объекты через ссылки
						2. e.g. объект базы данных может быть привязан к имени и приложение будет использовать имя для доступа к объекту
					3. Namespace/Пространство имен
						1. В JNDI ресурсы организованы в виде дерева, где каждый узел дерева является именем, а объект, связанный с узлом - ресурсом
				3. Способы доступа к ресурсам JNDI
					1. Через аннотации @Resource или @Inject в Java EE. Просто и гибко благодаря CDI: `@Resource(name = "java:/MyDataSource")`
					2. Вручную через InitialContext 
						1. Более традиционный способ
						2. Подходит для 
							1. Standalone apps
							2. Или когда нужно динамически досдавать ресурсы в зависимости от условий во время исполнения приложения
					3. Помимо этого ресурсы можно доставать в сервлетах и EJB бинах, но делается это через аннотации или инит контекст
			5. Необходимо реализовать RMI
				1. Для этого необходимо реализовать stubs (заглушки) на стороне клиента и skeletons на стороне сервера
			6. Использование:
				1. Регистрируем серверный объект RMI Registry
				2. Создается заглушка, реализующая тот же интерфейс что и серверный объект
				3. Эта заглушка отправляется клиенту и притворяется, что все методы есть
				4. При вызове происходит поиск объекта сервера
				5. Клиенту прилетает ответ
				6. Происходит обмен данными
				7. То есть в итоге получается что клиент работает с сервером через интерфейс с серверной заглушкой, думая что это сам серверный объект
			7. ![[JEE RMI.png]]
			8. Для реализации RMI объекты должны быть Serializable
		3. Профили Java EE
			1. В Java EE есть два профиля
				1. Web Profile
					1. Содержит самые важные компоненты, которые нужны для работы web-app, e.g.:
						1. Servlet
						2. JSP
						3. JSF
						4. CDI
						5. JPA
						6. Transaction API
						7. etc
				2. Full Profile
					1. Полный сборник Java EE, в нем дополнительно есть:
						1. JAX-RS - для реализации RESTful сервисов
						2. JAX-WS - для реализации SOAP
						3. JAXB - Java Architecture for XML Binding (для де- и маршализации джава классов в xml'ки)
						4. JACC
						5. etc
			2. Эти два профиля разделены, чтобы не перегружать базовую веб аппку лишними зависимостями
		4. Платформы Java
			1. ![[Java Platforms.png]]
		5. CDI beans
			1. Основные понятия
				1. CDI бины это специальные бины, которые позволяют разработчику использовать концепцию внедрения зависимостей
				2. CDI дает возможность управлять bean-компонентами
				3. Могут использовать перехватчики, стереотипы, декораторы, etc
			2. Основные характеристики
				1. Легковесность
					1. Для менее ресурсоемких задач их можно использовать вместо тяжелых EJB
				2. Поддержка контекстов
					1. Управление объектами в рамках контекста, таких как запросы, сессии, приложения, etc
				3. Инъекция зависимостей
					1. CDI бины могут внедряться в другие компоненты с использованием @Inject
				4. Это максимально абстрактная реализация паттерна CDI в Java EE
				5. Появились в Java EE 7, "клонируют" бины из спринга
				6. Совместимы со всеми фреймворками Java EE
				7. Конфигурируются аннотациями
				8. Для CDI используется универсальная аннотация @Inject
			3. Аннотации
				1. Для контекста
					1. Аналог контекста управляемых бинов JSF
					2. Определяет жизненный цикл бинов и их видимость друг для друга
					3. Задается аннотацией 
					4. Спецификацией определены 5 уровней контекста:
						1. @RequestScoped - существует в течение одного HTTP-запроса
						2. @SessionScoped
						3. @ApplicationScoped
						4. @ConversationScoped 
							1. Существует в течение текущего разговора (Conversation)
							2. Жизненным циклом компонента управляет программист
						5. @Dependent
							1. Жизненный цикл совпадает с жизненным циклом объекта, в котором он используется
							2. Используется по умолчанию
							3. Идейно похож на @NoneScoped из JSF
				2. Для внедрения зависимостей
					1. @Inject
						1. Используется для внедрения зависимостей
					2. @Produces
						1. Определяет поле или метод, который создает и возвращает экземпляры бина 
						2. Обычно используется для кастомных фабрик
					3. @Disposes
						1. Используется вместе с @Produces
						2. Метод с аннотацией вызывается перед удалением бина
						3. Указывает метод для удаления или освобождения ресурсов, созданных фабричным методом
					4. @Qualifier
						1. Пользовательские аннотации для уточненения внедрения зависимостей (например, при наличии нескольких бинов одного типа)
					5. @Named("$NAME")
						1. CDI-бин можно сделать доступным через имя
						2. Если имя не указано явно, по умолчанию используется имя класса с первой буквой в нижнем регистре
						3. Эта аннотация помогает избегать ошибок при использовании двух бинов с одинаковыми названиями
				3. Стереотипы/Stereotype
					1. Это аннотация, включающая в себя много аннотаций
					2. Можем создать свой стереотип и использовать его
					3. Существуют стандартные стереотипы, e.g. @Model
			4. Перерывание жизненного цикла 
				1. a.k.a. Interceptions
				2. Это классы, реагирующие на определенные события жизненного цикла бинов
				3. Чем то похожи на фильтры запросов в сервлетах
				4. Для создания Interceptors:
					1. Создаем кастомную аннотацию, помеченную `@InterceptorBinding`
					2. Создаем класс перехватчик, помечаем кастомной аннотацией и аннотацией `@Interceptor`
					3. Отмечаем метод для прерывания одной из аннотаций:
						1. @AroundInvoke 
							1. Самый часто-используемый
							2. Автоматически перехватывает вызов методов компонента
						2. @PostConstruct
							1. Вызывается после инициализации объекта
						3. @PreDestroy
							1. Вызывается перед уничтожением бина
						4. @PrePassivate // Не рассматривается в курсе
						5. @PostActivate // Не рассматривается в курсе
				6. Позволяют перехватывать вызовы методов бизнес-логики и жизненного цикла CDI-бинов
			5. Принципы инъекции
				1. //TODO
			6. Отличия от EJB
				1. В целом довольно схожи, можно инжектить друг в друга, тока CDI бины более легковесны
				2. CDI бины не обеспечивают горизонтальную масштабируемость
				3. CDI бины в отличии от EJB не зависяст от EJB-контейнера
				4. CDI бины управляют жизненным циклом с помощью контекстов, у EJB фиксированные контексты (например, сессия)
				5. CDI бины не поддерживают транзакции напрямую, но могут использовать EJB или JTA
				6. у CDI бинов мощная система событий, декораторов и интерсептеров (прерывателей), в отличии от EJB, у которых расширение ограничено стандартами EJB
				7. CDI бины довольно универсальны, а EJB специализированы для сложной бизнес-логики
		6. Enterprise Java Beans
			1. a.k.a. EJB
			2. Компоненты уровня бизнес-логики для "кровавого энтерпрайза"
			3. Предоставляют встроенную поддержку транзакций
			4. Контейнер может автоматически управлять транзакциями, что упрощает разработку
			5. Позволяет выполнять методы асинхронно с помощью аннотации `@Asynchronous`
			6. Два основных вида:
				1. Session Beans
					1. Похожи на JSF Managed Beans и CDI-бины, но обеспечивают много доп возможностей
					2. Могут быть прозрачно использованы в JSF
					3. Бывают разными:
						1. Stateless
						2. Stateful
						3. Singleton
				2. Message-driven Beans
					1. Предназначены для асинхронного выполнения задач и в JSF не используются
		7. Взаимодействие с БД (JPA, ORM)
			1. //TODO: EntityManager
			2. Иерархия абстракций
				1. Низкий уровень (JDBC)
					1. a.k.a. Java Database Connectivity
					2. Прямой доступ к БД через SQL-запросы
					3. Управление соединениями, транзакциями и обработка результатов выполняются вручную
				2. Средний уровень (JPA, ORM)
					3.  a.k.a. Java Persistence API, Object Relationship Mapping
					4. JPA это спецификация Java для ORM, входящая в состав Java EE
					5. Особенности JPA
						1. Абстрагирование над JDBC
						2. Интеграция в стек Java EE (CDI, JTA, EJB)
						3. Необходимость провайдеров (e.g. Hibernate), которые фактически преобразуют запросы в SQL и управление объектами
						4. ![[JEE JPA interaction with DB.png]]
					6. Аннотации
						1. @Entity
							1. Помечает bean как JPA Entity
						2. @Table
							1. Задает название таблицы для хранения Entity
						3. @Id
							1. Для каждой Entity обязательно должно быть поле, являющееся индентификатором
						4. @Column
							1. Помечает поле Entity как отображаемое на столбец таблицы
							2. Можно задавать атрибуты
						5. @GeneratedValue
							1. Для автоматической генерации идентификатора
					7. Отношения в JPA
						1. Бывают 4-ех видов:
							1. one2one
							2. one2many
							3. many2one
							4. many2many
					8. Object Relationship Mapping
						1. a.k.a. объектно-реляционное отображение
						2. Технология, которая облегчает взаимодействие между объектно-ориентированным программированием и реляционными БД, упрощая разработку
						3. С помощью ORM можно манипулировать данными в БД через объекты, не прибегая к написанию SQL-запросов вручную
						4. Это достигается за счет автоматического преобразлвания объектов в строки таблиц базы данных и обратно
						5. Это позволяет взаимодействовать с ними на более интуитивном уровне благодаря повышению абстракции
					9. Используются провайдеры (Hibernate, EclipseLink)
				3. Высокий уровень (Фреймворки, стеки, использующие JPA)
					1. e.g. Spring Data JPA, EJB, Quarkus Panache
					2. Обеспечивают еще большую абстракцию, предоставляя готовые решения для доступа к данным
		8. JAX-RS
			1. Фреймворк для построения RESTful веб-сервисов на базе Jakarta EE
			2. Ключевые особенности
				1. Основан на аннотациях
				2. Автоматическая сериализация и десериализация данных
				3. Совместим с CDI-beans
				4. Забирает на себя рутину по работе с HTTP
				5. "Под капотом" работает на сервлетах
				6. ![[JEE JAX-RS.png]]
			3. Основные концепции JAX-RS
				1. REST
					1. a.k.a. Representational State Transfer
					2. Архитектурный стиль для взаимодействия клиент-серверных приложений
					3. Базируется на HTTP-протоколе и HTTP-методах
				2. Ресурсы
					1. В JAX-RS ресурс - это сущность, которая может быть идентифицирована URI (Uniform Resource Identifier)
					2. Каждый ресурс представлен классом или методом, аннотированным специальными аннотациями
				3. Аннотации
					1. Основной механизм для определения маршрутов, методов HTTP, типов запросов/ответов, etc параметров
					2. Основные аннотации
						1. @Path
							1. Привязывает класс (в том числе его методы) REST ресурса к урлу из @Path
						2. @GET, @POST, @PUT, @DELETE
						3. @Produces, @Consumes
							1. Определяют типы тела запроса и тела ответа
					3. Аннотации для десериализации
						1. @PathParam
						2. @QuryParam
							1. Достаем URL-параметр
						3. @HeaderParam 
						4. @CookieParam
						5. @FormParam
						6. @ContextParam
				4. Для корректной работы необходимо настроить entry point и указать глобальный путь, к которому привязываются все ресурсы
	3. React
		1. Общие понятия, ключевые особенности, архитектура
			1. Это библиотека в отличии от ангуляра, который является фреймворком
			2. В отличии от ангуляра не реализует MVVM, а является просто V из MVC
			3. Использует компонентный подход
			4. Имеет древовидную структуру
			5. Реализует подход SPA
			6. Работает с Virtual DOM (VDOM)
				1. Изменения в странице вначале происходят в VDOM, а после уже переносятся в DOM
			7. Написание кода происходит в расширении .jsx или .tsx (но можно и классический .js или .ts использовать, разницы при компиляции нет)
			8. Поддерживает однонаправленный поток данных, где данные передается от родительских компонентов к дочерним через props, а управление состоянием внутри компонентов осуществляется с помощью хуков (e.g. useState, useEffect)
			9. Использует декларативный подход
				1. Декларативный - это когда мы говорим *что* хотим получить, а императивный - когда мы говорим *как* мы хотим это получить
			10. Архитектура React приложения
				1. Базируется на компонентах
				2. Есть два вида компонентов:
					1. Умные
						1. Управляют состоянием и логикой, умеют делать запросы, обрабатывать инфу, etc
					2. Глупые
						1. Отвечают **только** за отображение, сконцентрированы на UI, в основном используют Props для реюзабильности
				3. У каждого компонента есть свои State и Props
					1. Они нужны для отслеживания и управления состояния или для передачи информации от компонента в компонент
				4. Props
					1. Представляют собой способ передачи данных от родительского компонента к дочернему
					2. Позволяют родительскому компоненту настраивать дочерний, передавая ему значения (e.g. текст, числа, функции) через атрибуты в JSX
					3. Используются только для чтения 
						1. Дочерний компонент не может изменять их напрямую, так как управление данными остается у родительского компонента
				5. State
					1. Единственный правильный способ изменения состояния - вызов метода setState(newState)
					2. setState не меняет состояние целиком, а объединяет старое и новое
				6. Изменения state/props приводят к перерисовке компонента
		2. Состояния, управление состоянием, Flux & Redux & Redux Tool Kit (RTK)
			1. Управление состоянием в React - это процесс обработки данных приложения и их измнений
			2. Может быть локальным и глобальным
				1. Локальное:
					1. Ограничено одним компонентом
					2. Используется для управления интерфейсом в пределах одного компонента
					3. React предоставляет встроенные механизмы, такие как `useState` и `useReducer`
						1. useState
							1. Для простых состояний (e.g. флаги, простые формы)
						2. useReducer
							1. Для комплексной логики (e.g. состояния с множественными подзначениями, цепочки зависимых изменений)
				2. Глобальное:
					1. Flux
						1. Архитектурный паттерн
						2. Базируется на однонаправленном потоке данных
						3. Последовательность данных в Flux
							1. View -> Action -> Dispatcher -> Store -> (обновление) -> View
						4. Все логика работы с состоянием разделена на четыре ключевых элемента:
							1. Action
								1. Некоторое событие, которое должно привести к изменению состояния
									1. e.g. ответ от сервера, нажатие на кнопку в GUI
								2. С точки зрения библиотеки - любой JS объект, у которого есть идентификатор типа события и некоторая полезная нагрузка
								3. Упрощают передачу данных Диспетчеру
							2. Dispatcher
								1. Принимает Action'ы и рассылает нагрузку зарегистрированным обработчикам
								2. Узел, который перенаправляет действие в соответствующий Store
								3. Функция redux, которая генерирует события
							3. Store
								1. Контейнеры для состояния приложенция и бизнес-логики в обработчиках, зарегистрированных в Диспетчере, обновляются при получении Action'ов
							4. Controller Views / Представления
								3. React-компоненты, которые собирают состояния хранилищ и передают его дочерним компонентам через свойства
								4. Представление, отображающее данные из Store
						5. Помогает организовать состояние приложения и сделать поток данных предсказуемым
						6. Требует большого количества шаблонного кода и сложной настройки
					2. Redux
						1. Был разработан на основе идей из Flux
						2. ![[Pasted image 20250217174024.png]]
						3. Три ключевых принципа:
							1. Single Source of Truth
								1. Единый Store
							2. State isRead-Only
								1. Изменения только через Actions
							3. Changes are made with Pure Functions
								1. Reducers
						4. Redux API
							1. connect()
								1. Для классовых компонентов
							2. useSelector() & useDispatch
								1. Для функциональных компонентов
						5. Middleware
							1. redux-thunk
								1. Для ассинхронных действий
							2. redux-saga
								1. Для сложных side-эффектов
						6. Использует один глобальный Store для хранения состояния приложения
							1. В "правильном" React-приложении с использованием Redux у компонентов нет state'а
							2. А глобальный Store - этот синглтон
						7. Изменения состояния происходят строго через Action и Reducer
						8. Reducer: 
							1. Чистая функция
								1. То есть выходное значение зависит только от входных
							2. Принимает state и Action
							3. Возвращает либо неизменный state, либо копию store
						9. Action отправляется в Store через dispatch
							1. 
						10. Данные для отображения извлекаются с помощью Selector
						11. Redux значительно упрощает Flux:
							1. Убирает Dispatcher
							2. Использует единый Store
							3. Архитектура становится более строгой и понятной
						12. Общий принцип Redux'а
							1. При получении данных размещаем их в глобальном сторе
							2. Связываем с каждой порцией данных специальную метку
							3. Если данные изменяются по определенной метке, то библиотека сама перезапросит данные с сервера
							4. Также раз в n-ое время библиотека может инвалидировать кэшированные данные, что позволяет увидеть обновление, сделанное другим пользователем
					3. Redux Toolkit (RTK)
						1. Официальная библиотека от создателей Redux
						2. Официальный инструмент для упрощения работы с Redux, популярный фреймворк управления состоянием в JavaScript
						3. Основные функции Redux Tookit
							1. configureStore
								1. Упрощает создание Redux Store
								2. Автоматически добавляет middleware(e.g. redix-think)
								3. Включает DevTools
							2. createSlice
								4. Позволяет легко создавать редюсеры и действия
								5. Убирает необходимость в ручном определении action'ов, creators и констант
							3. createAsyncThunk
								1. Упрощает обработку асинхронных операций (e.g. запросы к API)
							4. RTK Query
								2. Функционал для работы с данными REST/GraphQL API
								3. Автоматически управляет кэшированием, рефетчингом и синхронизацией
		3. Плюсы-минусы
			1. +:
				1. Архитектура основана на компонентах (соответственно это хорошо для реюзабельности)
				2. Virtual DOM
					1.  Снижение количества изменений реального DOM
				3. Декларативный синтаксис
				4. Большое количество документации и большое сообщество
				5. Кросс-платформенная разработка с помощью React Native
				6. JSX
				7. Обратная зависимость
			2.  -:
				1. Порог вхождения
				2. Относительно сложный сетап (конфигурация вебпака, babel и т.д.), немало повторяющегося кода
				3. Управление состоянием между компонентами без дополнительных библиотек бывает весьма костыльным
				4. Плохо оптимизированные компоненты могут привести к ухудшениям производительности в больших проектах
		4. JSX
			1. В React существует свой формат файлов - JSX
			2. Это надстройка над JS, которая позволяет писать внутри на HTML'е
			3. Можно использовать как обычные HTML теги, так и кастомные React компоненты
			4. Так как JSX это JS XML, то соответственно используется синтаксис XML, и, соответственно, все теги **обязательно** должны быть закрытыми (даже картинки)
			5. return всегда должен возвращать только один элемент
				1. Если хотим вернуть несколько элементов, то надо обернуть это в один общий `<div>...</div>`
			6. После компиляции (обычно с помощью babel) превращается в вызовы JS-функций
			7. Можно использовать JS-выражения внутри JSX с помощью фигурных скобок
		5. Навигация, React Router
			1. Навигация реализуется с помощью библиотеки React Router
			2. Библиотека позволяет создавать маршруты и управлять переходами между страницами или компонентами
			3. Используется компонентный подход для: 
				1. Определения маршрутов (`Route`)
				2. Управления историей браузера  (`useNavigate`)
			4. Из-за компонентного подхода обеспечивается удобная работа с динамическим URL'ом
			5. Каждый маршрут ассоциируется с определенным компонентом, который рендерится при совпадении пути (e.g. `/home` условно отображает компонент Home.jsx, а `/about` - About.jsx)
			6. Поддерживается несколько типов маршрутизации:
				1. Клиентская (SPA)
				2. Серверная (SSR)
			7. Библиотека позволяет работать с:
				1. Динамическими сегментами маршрутов
				2. Вложенными маршрутами
				3. Private Routes
				4. Перенаправлениями
			8. Для обеспечения интерактивности предоставляются следующие компоненты:
				1. Link - для переходов без перезагрузки страницы
				2. Хуки (e.g. useParams) для извлечения параметров маршрута
			9. Благодаря этой библиотеке просто реализовывать гибкую навигацию 
		6. React Effects: что такое, для чего применяется
			1. Этот хук:
				1. Обеспечивает интерактивность
				2. Позволяет обрабатывать события (e.g. изменения какого-либо состояния компонента)
				3. Дает возможность выполнять side-effects, e.g. обновление DOM
	4. Angular 
		1. Общие понятия, ключевые особенности, архитектура
			1. Используется архитектура MVVM
			2. Используется для создания клиентских SPA (Single Page Applications) приложений
			3. Использует на TypeScript
			4. Основа Angular - модули
				1. AppModule - главный модуль, точка входа
			5. В каждом модуле есть компонент(ы)
				1. Компоненты - основные строительные блоки, которые управляют частью пользовательского интерфейса
				2. Компонент - это директива с HTML-шаблоном
				3. За объявление компонента отвечает декоратор @Component()
				4. Каждый компонент имеет три части:
					1. TypeScript class
					2. HTML-шаблон
					3. CSS-стиль
				5. Основные свойства объекта, которые принимает декоратор:
					1. selector - название компонента
					2. template - HTML разметка в виде строки (или путь к HTML файлу)
					3. imports
					4. providers - список сервисов, поставляющих данные для компонента
					5. styles - CSS
					6. standalone - boolean
				6. Каждый компонент связан с представлением (HTML-шаблоном) и логикой (TypeScript-классом)
					1. Представления - это HTML шаблоны, связанные с компонентами
					2. Для связывания данных используется декларативный стиль
						1. Можно использовать для этого директивы //TODO: добавить ссылку на директивы
							1. *ngIf
							2. *ngFor
						2. И синтаксис двустороннего связывания
							1. `[()]`
				7. По факту отвечают за представление и связаны с ним двусторонней связью
				8. Существуют декораторы свойств:
					1. @Input() - для получения данных
					2. @Output() - для отправки данных, отправляющих их в качестве производителей событий
				9. Может делегировать какие либо из своих задач сервисам
				10. Проекция контента
			6. Сервисы в Angular
				1.  Это класс, который является поставщиком данных
				2. Инкапсулируют бизнес логику приложения
				3. Могут предоставлять интерфейс взаимодействия между отдельными, не связанными друг с другом компонентами
				4. Реализуются в виде отдельных классов в соответствии с принципами ООП
				5. Доступ от компонентов к сервисам реализуется с помощью DI
				6. Для каждого сервиса должен быть зарегистрирован как минимум один провайдер
					1. Провайдеры задаются в метаданных сервиса или в метаданных компонента
			7. Директивы
				1. Предназначение - преобразование DOM заданным образом, наделение элемента поведением
				2. По своей реализации директивы практически идентичны компонентам
				3. Есть три вида директив:
					1. Компоненты
						1. Используют templat'ы
						2. Самый распространенный тип директив
					2. Структурные - взаимодействуют с DOM (производят CRUD элементов в DOM'е)
						1. Есть встроенные: 
							1. `*ngIf`
								1. Добавляет или удаляет элемент из DOM-дерева в зависимости от истинности переданного выражения
								2. e.g. `<app-item-detail *ngIf="isActive" [item]="item"></app-item-detail>`
							2. `*ngFor`
								4. Используется для визуализации массива данных
								5. Применяется к блоку HTML-кода, определяющего как должны отображаться данные элемента массива
								6. Angular использует этот HTML как шаблон для всех последующих элементов в массиве
								7. `<div *ngFor="let item of items">{{item.name}}</div>`
							3. Сейчас ngIf и ngFor немного неактуальны, так как в angular19 добавили @if и @for, они более удобные и их можно использовать без лишних импортов
							4. `ngSwitch`
								1. Эмулирует работу оператора switch применительно к шаблонам 
					3. Атрибуты - задают элементам другое поведение
						1. Точно так же есть встроенные:
							1. `[ngStyle]` - принимает объект, в котором key это наименования CSS-свойств, а value - возможные значения соответствующих CSS-свойств
								1. `<div [ngStyle]="currentStyles">Этот див инициализрован как курсив, нормальным шрифтом и очень большим (24px)</div>`
								2. ![[ngStyle.png]]
							2. `[ngClass]` - точно так же принимает объект, но здесь key - это наименование классов, а value - boolean
								1. Если выражение истинно, класс будет добавлен к списку уже имеющихся классов
								2. `<div [ngClass]="isSpecial ? 'special' : ''">This div is special</div>`
				4. Создаются с помощью декоратора @Directive() с конфигурационным объектом
				5. Имеется множество встроенных директив (`*ngFor`, `*ngIf`), но зачастую их недостаточно для больших приложений, so приходится реализовывать свои
			8. Декораторы
				1. Специальные функции, добавляющие метаданные к:
					1. классам:
						1. Применяются к классам и добавляют метаданные, описывающие их назначение
						2. e.g.:
							1. @Component
								1. Идентифицирует класс, расположенный непосредственно под ним, как класс компонента и определяет его метаданные //
							2. @Directive
							3. @Injectable
							4. @NgModule
								1. Может связывать свои компоненты со смежным кодом, таким как сервисы, для формирования функциональных единиц
					2. методам
					3. свойствам
						1. Применяются к свойствам класса для связывания с внешними данными
						2. e.g.
							1. @Input() - декоратор, используемый для получения данных
							2. ![[Pasted image 20250207172346.png]]
							3. Так же можно указать required опцию, что заданный вход всегда будет иметь значение
								1. ![[Pasted image 20250207172543.png]]
							4. Так же можно указать transform функцию для изменения значения ввода, когда оно установлено
								1. ![[Pasted image 20250207173008.png]]
							5. Так же можно провер
							6. @Output() - декоратор, используемый для отправки данных, выставляя их в качестве производителей событий
								1. ![[Pasted image 20250207165150.png]]
					4. параметрам
				2. 
	5. Frontend
2. Практика