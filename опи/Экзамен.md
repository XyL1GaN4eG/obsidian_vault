1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ
2. Модели ЖЦ (последовательная, инкрементная, эволюционная).
3. Водопадная (каскадная) модель.
4. Методология Ройса.
5. Традиционная V-chart model J.Munson, B.Boehm.
6. Многопроходная модель (Incremental model).
7. Модель прототипирования (80-е).
8. RAD методология.
9. Спиральная модель.
10. UML Диаграммы: Структурные и поведенческие.
11. UML: Use-case модель.
12. UML: Диаграмма классов.
13. UML: Диаграмма последовательностей
14. UML: Диаграмма размещения
15. *UP методологии (90-е). RUP: основы процесса.
16. RUP: Фаза «Начало».
17. RUP: Фаза «Проектирование».
18. RUP: Фаза «Построение».
19. RUP: Фаза «Внедрение».
20. Манифест Agile (2001).
21. Scrum.
22. Disciplined Agile 2.X (2013).
23. Требования. Иерархия требований.
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.
41. Системы автоматической сборки: предпосылки появления
42. Системы сборки: Make и Makefile.
43. Системы сборки: Ant. Команды Ant.
44. Системы сборки: Ant-ivy.
45. Системы сборки: Maven. POM. Репозитории и зависимости.
46. Maven: Структура проекта. GAV.
47. Maven: Зависимости. Жизненный цикл сборки. Плагины.
48. Системы сборки: Maven. POM. Репозитории и зависимости.
49. Системы сборки: GNU autotools. Создание конфигурации проекта.50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
50. Сервера сборки/непрерывной интеграции.
51. Основные понятия тестирования. Цели тестирования.
52. Понятие полного тестового покрытия и его достижимости. Пример.
53. Статическое и динамическое тестирование.
54. Автоматизация тестов и ручное тестирование.
55. Источники данных для тестирования. Роли и деятельности в тестировании.
56. Понятие тестового случая и сценария.
57. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
58. Модульное тестирование. Junit 4.
59. Интеграционное тестирование. Стратегии интеграции.
60. Функциональное тестирование. Selenium.
61. Техники статического тестирования. Статический анализ кода.
62. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
63. Тестирование системы в целом. Альфа- и бета-тестирование.
64. Аспекты быстродействия системы. Влияние средств измерения на результаты.
65. Ключевые характеристики производительности.
66. Нисходящий метод поиска узких мест.
67. Пирамида памяти и ее влияние на производительность.
68. Мониторинг производительности: процессы.
69. Мониторинг производительности: виртуальная память.
70. Мониторинг производительности: буферизированный файловый ввод-вывод.
71. Мониторинг производительности: Windows и Linux.
72. Системный анализ Linux "за 60 секунд".
73. Создание тестовой нагрузки и нагрузчики.
74. Профилирование приложений. Основные подходы.
75. Компромиссы (trade-offs) в производительности.
76. Рецепты повышения производительности при высоком %SYS.
77. Рецепты повышения производительности при высоком %IO wait.
78. Рецепты повышения производительности при высоком %Idle.
79. Рецепты повышения производительности при высоком %User.



asd
1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ
	1.  Жизненный цикл - время существования программы от момента замысла до вывода ее из эксплуатации. Все этапы жизненного цикла описаны в ISO
	2. Существуют 8 основных этапов:
		1. Разработка требования
		2. Анализ
		3. Проектирование архитектуры
		4. Разработка
		5. Тестирование 
		6. Внедрение в эксплуатацию
		7. Эксплуатация
			1. В эксплуатацию входят:
				1. Багфиксы
				2. Поддержка пользователей
				3. Обновления
		8. Вывод из эксплуатации
			1. В этот этап входят:
				1. Сохранность накопленных файлов 
				2. Миграция на новое ПО
	3. Существуют 7 групп ЖЦ ПО:
		1. Процесс согласования
		2. Процесс организации обеспечения
		3. Процессы проекта
		4. Технологические процессы
		5. Процесс реализации программного средства
		6. Процесс поддержки программных средств
		7. Процесс повторного использования программных средств
2. Модели ЖЦ (последовательная, инкрементная, эволюционная).
	1. Последовательная 
		1. A.k.a. однократная, waterfall
		2. Определены все требования, один этап разработки
		3. Один последовательный проход
		4. Получившиеся результаты окончательны и, как правило, не подлежат пересмотру
	2. Инкрементная
		1. Определены все требования, несколько этапов
		2. Система разрабатывается по частям и для каждой части производятся все этапы жизненного цикла
	3. Эволюционная
		1. Определены не все требования
		2. Разрабатывается прототип, который с течением времени развивается
	4. |Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
	   |---|----|----|---|
	   |Последовательная|Да|Нет|Нет|
	   |Инкрементная|Да|Да|Maybe|
	   |Эволюционная|Нет|Да|Да|
3. Водопадная (каскадная) модель.
	1. Разработана в 60-х
	2. Описана Ройсом в 70-х
	3. Суть в том, что есть 7 фаз разработки ПО, которые идут друг за другом только, и только в этом порядке, и есть итерации между ними:
		1. Сбор требований к системе
		2. Сбор требований к ПО
		3. Анализ требований
		4. Проектирование дизайна ПО
		5. Кодирование
		6. Тестирование
		7. Эксплуатация системы
	4. Можно откатится к предыдущей фазе, но это сложно и не особо предусмотренно, так как потенциально это может привести к двукратному росту сроков и стоимости разработки
	5. |Плюсы|Минусы|
	   |---|---|
	   |Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и слоэным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
	   |Автоматизация отдельных несвязных задач|Позднее тестирование|
4. Методология Ройса.
	1. //todo: загрузить картинку, но учить я ее не буду нахуй надо
	2. По сути - те же яйца, только в профиль (с доп шагами)
	3. Описаны следующие шаги:
		1. Предварительный дизайн - между программными требованиями и анализом
			1. Программисты и аналитики не допускаются
			2. На этом шаге предполагается спроектировать, определить и создать модель обработки данных, а также создать документ-обзор системы
			3. 
		2. Написание документации для всей системы:
			1. Требования к системе
			2. Спецификация предварительного дизайна
			3. Спецификация дизайна интерфейсов
			4. Финальная спецификация дизайна системы
			5. План тестирования
			6. Инструкция пользовательской эксплуатации
		3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа основных характеристик ПО
		4. Тестирование с привлечением независимых экспертов
			1. Наиболее рискованная фаза с точки зрения денег и сроков
		5. Несколько этапов подключения пользователей:
			1. Предварительный
			2. Критический
			3. Финальный просмотр
5. Традиционная V-chart model J.Munson, B.Boehm.
	1. Та же последовательность действий, что и в водопадике, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирование
	2. Определяются следующие этапы:
		1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка
		2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении
		3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование
		4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование
		5. Кодирование $\leftrightarrow$ Юнит-тестирование
6. Многопроходная модель (Incremental model).
	1. Частный случай V-chart модели
	2. Параллельная разработка частей продукта, а в последствии интегрирование воедино
		1. На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя:
			1. Детальное проектирование
			2. Кодирование
			3. Интеграция протот
	3. Снижение стоимости внесения изменений
	4. Возможность использования частично разработанной системы
	5. Имеет тенденцию к устареваниюю, деградации
		1. Соответственно, требует рефакторинга с течением времени
	6. При параллельной разработке несколькими командами требует стабильного API, спланированного заранее
	7. Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно
	8. Из-за всех факторов, сложно оценивать стоимость разработки ПО
7. Модель прототипирования (80-е).
	1. ![[Pasted image 20250612180036.png]]
	2. В чем суть:
		1. Быстро планируем всю итерацию
		2. Быстро анализируем требования и подходы к реализации
		3. Разрабатываем прототип
		4. Показываем заказчику
		5. Если заказчик одобряет, то:
			1. Разрабатываем окончательную версию ПО
			2. Тестируем
			3. Внедряем ПО
			4. Сопровождаем
			5. В ином случае:
				1. Переходим к третьему шагу (разработке прототипа), пока заказчик не скажет что его все устраивает
8. RAD методология.
	1. ![[Pasted image 20250612184140.png]]
	2. RAD - Rapid Application Dev Model - Быстрая разработка приложений
	3. Порождена IBM в 80-х, обнародована в 1991
	4. Разновидность инкрементной модели
	5. Пользователь принимает непосредственное участие в процессе разработки
	6. Временные рамки одного цикла **жестко** ограничены
	7. 
	8. В чем суть:
	9. Фазы:
		1. Планирование
			1. Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
			2. Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение
		2. Пользовательское проектирование
			1. На этом этапе:
				1. Пользователи взаимодействуют с системными аналитикам
				2. Разарабатывают модели и прототипы
			2. Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям
		3. Конструирование
			1. На этом этапе происходит разработка программ и приложений
			2. Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов
		4. Переключение
			1. Включает в себя:
				1. Конверсию данных
				2. Тестирование
				3. Переход на новую систему
				4. Тренировку пользователей
	10. Позволяет обеспечить:
		1. Быстроту продвижения програмнного продукта на рынок
		2. Интерфейс, устраивающий пользователя
		3. Легкую адаптируемость проекта к изменяющимся требованиям
		4. Простоту развития функциональности системы
9. Спиральная модель.
	1. По сути - это совмещение прототипной модели + куча тестирования из V-chart модели
	2. Особое внимание уделяется управлению рисками
		1. Вследствии, специфический анализ на каждой итерации
	3. Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа
	4. На разных фазах спирали разрабатываются основные концепции ПО
	5. |Достоинства|Недостатки|
	   |---|---|
	   |Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
	   |Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|
10. UML Диаграммы: Структурные и поведенческие.
	1. Если кратко - то основное значение - графическое представление различных аспектов разработки ПО
	2. UML - графический язык моделирования общего назначения
		1. Предназначен для:
			1. Спецификации
			2. Визуализации
			3. Проектированию и документированию артефактов
	3. UML-диаграммы делятся на:
		1. Структурные
			1. К ним относятся:
				1. Доменные модели
				2. Диаграммы развертывания
			2. Нужны для:
				1. Статического описания системы
				2. Демонстрации архитектуры, конфигурации, специфических элементов предметной области
		2. Поведенческие
			1. К ним относятся:
				1. Диаграммы прецедентов использования
					1. a.k.a. Use-case диаграммы
					2. Описывают высокоуровневые требования к системе
				2. Диаграммы последовательностей
					1. Описывают последовательность алгоритма
				3. Диаграммы состояний
					1. Описывают состояния системы
			2. Представляют собой динамическую картину действий, происходящих в системе
11. UML: Use-case модель.
	1. Поведенческая диаграмма
	2. Отображает динамическое поведение в UML
	3. Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов
	4. Actors (акторы) - люди/организации, которые работают под определенными ролями внутри системы
	5. Use-case - прецедент использования
	6. Association  - ассоциация, использование
	7. Include - включение
		1. Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов
	8. Extend - точка расширения функционала
		1. Указывает расширение от базового функционала
	9. Generalization - обобщение
	10. System Boundary - границы системы
12. UML: Диаграмма классов.
	1. Диаграмма, предназначенная для представления модели статической структуры программной системы в терминологии классов объектно-ориентированного программирования
	2. Может отражать:
		1. Различные взаимосвязи между отдельными сущностями предметной области
			1. f.e.: объекты и подсистемы
		2. Внутреннюю структуру объектов 
			1. f.e.: моля, методы
		3. Типы отношений
			1. Наследование, реализация интерфейсов
	3. Не указывается информация о временных аспектах функционирования системы
	4. Является примером структурной диаграммы 
	5. Отображает в первом приближении реализованную предметную область
13. UML: Диаграмма последовательностей
	1. a.k.a. диаграмма последовательностей a.k.a. диаграмма конечных автоматов
	2. Поведенческая диаграмма
	3. Отображает модель конечных автоматов
	4. Представляет собой набор состояний и условий переходов между ними
14. UML: Диаграмма размещения
	1. В контексте UML развертывание - это процесс распределения артефактов по узлам или экземпляров артефактов по экземплярам узлов
	2. Является примером структурной диаграммы
	3. Отображает физическую архитектуру размещения ПО + возможности его использования
	4. f.e.:
		1. Диаграмма с нарисованной серверной машиной, на которую крутится веб-сервер с JVM, в которой крутится микросервис плюс где то нарисована пользовательская машина с браузером 
15. \*UP методологии (90-е). RUP: основы процесса.
	1. RUP был построен на базе процесса OOSE и включил в себя элементы из процессов OMT, OOSE и метода Буча, которыми занимались в то время его создатели
	2.  \*UP идеи берут за собой идею о создании четкой унифицированной структуры создания ПО, подходящего для любой команды людей, позволяющей создать с ее помощью любой программный продукт
	3. Частный пример \*UP - RUP
	4. Разработка представляет из себя инкрементно-эволюционный процесс
	5. Разработка разбита на фазы
	6. Дисциплина - набор правил и указаний, необходимых для решения определенной задачи
	7. Цель этой методологии - конкретезировать действия разработчиков для того, чтобы максимально избежать сюрпризов и конкретезировать процесс разработки
	8. Всего существует 4 фазы:
		1. Interception/Начало
		2. Elaboration/Проектирование
		3. Construction/Построение
		4. Transtion/Внедрение
	9. Явно описаны все роли, которые принимают участие в создании ПО (около 30 ролей)
		1. Роль - группа обязанностей, которую берет на себя определенный участник команды
			1. У каждой роли есть набор деятельностей
			2. На входе и выходе деятельности используются, создаются и модифицируются артефакты
				1. Артефакты - любой результат труда роли, e.g. диаграмма, документ, программный код и пр.
			3. Деятельность четко регламентирована
	10. В отличии от других моделей жизненного цикла, в RUP каждый процесс детально описан и связан с другими процессами
	11. Любая фаза в RUP заканчивается вехами
		1. Веха - момент времени для принятия решения о дальнейших действиях, то есть либо переход на следующую фазу, либо проведение дополнительных работ на данной фазе
		2. Решение принимается заинтересованными лицами/стейкхолдеры (инвесторы, руководство высшего звена, исполнители работ)
			1. Обычные пользователи не являются заинтересованными лицами, так как для них ПО  - инструмент, а не источник дохода
	12. Сам по себе RUP как программный продукт представляет набор связанных гиперссылками страниц HTML, каждая их которых описывает элемент процесса разработки
16. RUP: Фаза «Начало».
	1. Цели
		1. Определить границы/области применения проекта
		2. Описать основные сценарии использования системы
		3. Предложить возможное технологическое решение
		4. Рассчитать стоимость и разработать график работ
		5. Оценить риски
		6. Подготовить окружение
	2. Веха "Lifecycle Objects"
		1. Оценка сроков?
		2. Первоначальная стоимость?
		3. Требования?
		4. Приоритеты?
		5. Технологии?
		6. Оценены риски и выбраны стратегии смягчения последствий?
17. RUP: Фаза «Проектирование».
	1. Цели
		1. Финализировать базовую архитектуру системы
		2. Разработать прототипы на основе архитектуры
		3. Убедиться в том, что архитектура, планы, сроки стабильны, риски разработаны и учтены
	2. Веха "Lifecycle architecture"
		1. Концепция, требования, архитектура проекта стабильны?
		2. Сформированы критерии тестирования прототипов?
		3. Тестирование прототипов показало отсутствие основных рисков?
		4. Планы разработки подробны и приемлимы по цене?
		5. Соотношение запланированных и затраченных расходов приемлимо? 
		6. Стороны подтверждают выполнимость проекта?
18. RUP: Фаза «Построение».
	1. Цели
		1. Экономически эффективно, в максимально короткие сроки реализовать программное обеспечение.
		2. Итеративно провести анализ, проектирование, разработку и тестирование продукта, создать необходимые выпуски (альфа, бета…).
		3. Подготовить продукт, окружение и пользователей к развертыванию.
	2. Веха “Initial Operation Capability”:
		1. Достаточно ли стабилен выпуск для передачи заказчику?
		2. Готова ли принимающая сторона?
		3. Актуальны ли еще расценки на программный продукт?
19. RUP: Фаза «Внедрение».
	1. Цели этой фазы:
		1. Развернуть систему, базу данных на целевой платформе
		2. Обучить пользователей пользоваться продуктом
		3. Запустить маркетинг и продажи, каналы сбыта
		4. Отладить сбои, выкатить хотфиксы и пр.
		5. Убедиться в самодостаточности пользователей
		6. Провести открытый анализ со всеми стейкхолдерами на соответствие программного продукта заявленной концепции
	2. Веха “Release”:
		1. Пользователи удовлетворены?
		2. Финальная стоимость разработки приемлема?
20. Манифест Agile (2001).
	1. Люди и взаимодействие важнее процессов и инструментов
	2. Работающий продукт важнее исчерпывающей документации
	3. Сотрудничнство с заказчиком важнее заключенного согласованного когнтракта
	4. Готовность к изменениям важнее следования первоначальному плану
21. Scrum.
	1. Основной и единственный служебный артефакт скрам - бэклог - упорядоченный по приоритетам список требований с оценкой трудоемкости разработки
	2. Бэклог продукта - более общий и состоящий из бизнес-требований
	3. Бэклог спринта - более детальный, с учетом технических особенностей реализации
	4. Спринт - период времени длиной 1-4 недели
		1. За время спринта разработчики реализуют выбранный набор требований из беклога
		2. Каждый спринт заканчивается демонстрацией проделанной работы заказчику
		3. Через несколько спринтов проводятся ретроспектива (работа над ошибками, перераспределение ролей)
		4. Каждый день во время спринта происходит скрам-митинг (дейлик) утром, где каждый участник команды 
			1. Отчитывается о проделанной работе
			2. Планирование планов к следующей встрече %% fixme: масло масляное %%
	5. Команда состоит из 3-10 людей
	6. Выделяются две особые роли:
		1. Продакт овнер
			1. Определяет порядок разработки требований из бэклога
		2. Скрам-мастер
			1. Ответственен за организацию скрам-митингов
			2. Помогает команде планировать спринты
			3. Следит за внутренними отношениями в команде
	7. Достоинства скрам:
		1. Простота
		2. Минимум административной работы 
		3. Максимальная концентрация на работоспособном коде
22. Disciplined Agile 2.X (2013).
	1. Внебрачный сын RUP и Scrum
	2. Инкрементальная модель разработки опирается на модель спринтов
	3. Что взято из рап:
		1. 3 фазы:
			1. Начало
			2. Построение
			3. Внедрение
		2. Описание каждой роли в разработке
	4. Что взято из скрам:
		1. Спринты
	5. Что придумано уже в DAD:
		1. Управление архитектурой
		2. Переиспользование кода
		3. Управление персоналом
		4. Непрерывное улучшение процессов разработки
23. Требования. Иерархия требований.
	1. 
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.
41. Системы автоматической сборки: предпосылки появления
42. Системы сборки: Make и Makefile.
43. Системы сборки: Ant. Команды Ant.
44. Системы сборки: Ant-ivy.
45. Системы сборки: Maven. POM. Репозитории и зависимости.
46. Maven: Структура проекта. GAV.
47. Maven: Зависимости. Жизненный цикл сборки. Плагины.
48. Системы сборки: Maven. POM. Репозитории и зависимости.
49. Системы сборки: GNU autotools. Создание конфигурации проекта.50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
50. Сервера сборки/непрерывной интеграции.
51. Основные понятия тестирования. Цели тестирования.
	1. Основные понятния
		1. Mistake -- ошибка разработчика. Человеческое деяние, которое в конечном итоге привело к получению неверного результата. В широком смысле отклонение от истины или правил. 
		2. Fault -- дефект, изъян, Неверный шаг в алгоритме (или неверное определение данных) в компьютерной программе. Следствие ошибки, потенциальная причина неисправности. 
		3. Failure -- неисправность, отказ или сбой -- наблюдаемое проявление дефекта, в том числе, крах или падение программы. невозможность выполнить с использованием программы задачу, получить
		4. Error -- невозможность выполнить с использованием программы задачу, получить верный результат.
	2. Цели тестирования:
		1. Обнаружение дефектов. 
		2. Повышение уверенности в уровне качества. 
		3. Предоставление информации для принятия решений. 
		4. Предотвращение дефектов.
52. Понятие полного тестового покрытия и его достижимости. Пример.
53. Статическое и динамическое тестирование.
54. Автоматизация тестов и ручное тестирование.
55. Источники данных для тестирования. Роли и деятельности в тестировании.
56. Понятие тестового случая и сценария.
57. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
58. Модульное тестирование. Junit 4.
59. Интеграционное тестирование. Стратегии интеграции.
60. Функциональное тестирование. Selenium.
61. Техники статического тестирования. Статический анализ кода.
62. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
63. Тестирование системы в целом. Альфа- и бета-тестирование.
64. Аспекты быстродействия системы. Влияние средств измерения на результаты.
65. Ключевые характеристики производительности.
66. Нисходящий метод поиска узких мест.
67. Пирамида памяти и ее влияние на производительность.
68. Мониторинг производительности: процессы.
69. Мониторинг производительности: виртуальная память.
70. Мониторинг производительности: буферизированный файловый ввод-вывод.
71. Мониторинг производительности: Windows и Linux.
72. Системный анализ Linux "за 60 секунд".
73. Создание тестовой нагрузки и нагрузчики.
74. Профилирование приложений. Основные подходы.
75. Компромиссы (trade-offs) в производительности.
76. Рецепты повышения производительности при высоком %SYS.
77. Рецепты повышения производительности при высоком %IO wait.
78. Рецепты повышения производительности при высоком %Idle.
79. Рецепты повышения производительности при высоком %User.
