## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ. 

Жизненный цикл ПО: 

- Разработка требований (заказчик, программисты)
- Анализ
- Проектирование архитектуры
- Разработка
- Тестирование
- Внедрение в эксплуатацию
- Эксплуатация (багфиксы, поддержка пользователей, обновления)
- Вывод из эксплуатации
	- Сохранность накопленных файлов
	- Миграция на новое ПО

Группы ЖЦ ПО: 

1. Процесс согласования (2)
2. Процесс организационного обеспечения (5)
3. Процессы проекта (7)
4. Технологические процессы (11)
5. Процесс реализации программного средства (7)
6. Процесс поддержки ПС (8)
7. Процесс повторного использования ПС

## 2. Модели ЖЦ (последовательная, инкрементная, эволюционная)

#### Последовательная 
-  A.k.a. однократная, waterfall
-  Определены все требования, один этап разработки
-  Один последовательный проход
-  Получившиеся результаты окончательны и, как правило, не подлежат пересмотру

#### Инкрементнеая
- Определены не все требования
- Разрабатывается прототип, который с течением времени развивается

###### Сравнение стратегий
|Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
|---|----|----|---|
|Последовательная|Да|Нет|Нет|
|Инкрементная|Да|Да|Maybe|
|Эволюционная|Нет|Да|Да|

## 3. Водопадная (каскадная) модель
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcgj2PIgMq0q2Jhji2fL1A6NOf8alPM-GHervvvjrMAcLqkf2DINsZiu5lkalI72crfZSFaSRiID0-zVDM9NfU0Zq0DtSb2a7l_FH7RBAkbzG54EILaX0k9zfK2l-7E2WpghTykpf4mc_9QPT-h-3xhkCQY?key=1pD2kcEQ8Lrk26WoBNVmmQ)


- Разработана в 60-х
- Описана ройсом в 70-х

**Суть** в том, что есть 7 фаз раработки ПО, которые идут друг за другом только, и только в этом порядке и между ними есть итерации:

1. Сбор требований к системе
2. Сбор требований к ПО
3. Анализ требований
4. Проектирование дизайна ПО
5. Кодирование
6. Тестирование
7. Эксплуатация

- Можно откатиться к предыдущей фазе, но это сложно и не особо предусмотрено, так как потенциально это может привести к двухкратному росту сроков и стоимости разработки

|Плюсы|Минусы|
|---|---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
|Автоматизация отдельных несвязных задач|Позднее тестирование|

## 4. Методология Ройса
Водопад, но с дополнительными шагами
 
 1. Предварительный дизайн - между программными требованиями и анализом
	 - Программисты и аналитики не допускаются
	 - На этом этапе предполагается спроектировать, определить и создать модель обработки данных, а так же создать документ-обзор системы
2. Написание документации для всей системы
	- Требования к системе
	- Спецификация предварительного дизайна
	- Спецификация дизайна интерфейсов
	- Финальная спецификация дизайна системы
	- План тестирования
	- Инструкция пользовательской эксплуатации
3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа характеристик ПО
4. Тестирование с привлечением независимых экспертов
	- Наиболее рисковая фаза с точки зрения денег и сроков
5. Несколько этапов подключения пользователей
	- Предварительный
	- Критический
	- Финальный просмотр


## 5. Традиционная V-chart model J. Munson, B.Boehm

Та же последовательность действий, что и в водопаде, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирования

Определяются следующие этапы:
1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка  
2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении  
3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование  
4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование  
5. Кодирование $\leftrightarrow$ Юнит-тестирование  

## 6. Многопроходная модель (Incremental model)
**Частный случай V-chart модели**

Параллельная разработка частей продукта, а в последствии интегрирование воедино
- На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя
	- Детальное проектирование
	- Кодирование
	- Интеграция протот

Снижение стоимости внесения изменений

Возможность использования частично разработанной системы

Имеет тенденцию к устареванию, деградации
- Соответственно требует рефакторинга с течением времени

При параллельной разработке несколькими командами требует стабильного API

Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно

Из-за всех факторов, сложно оценивать стоимость разработки ПО

## 7. Модель прототипирования (80-е)
![[Прототипирование.png]]  
#### Суть
##### Фазы:
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
- Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками 
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованием

3. Конструирование
- На этом этапе происходит разработка программ и приложений
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсия данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить:
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
-  Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 8. RAD методология
![[RAD.png]]

RAD - Rapid Application Dev Model - Быстрая разработка приложение

Порождена IBM в 80-х, обнародована в 1991
Разновидность инкрементной модели
Пользователь принимает непосредственное участие в процессе разработки
Временные рамки одного цикла **жестко** ограничены

#### Суть

##### Фазы
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
-  Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям

3. Конструирование
- На этом этапе происходит разработка программ и приложений 
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсию данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
- Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 9. Спиральная модель
По сути - это совмещение прототипной модели + куча тестирования из V-chart модели

Особое внимание уделяется управлению рисками
- Вследствие, специфический анализ на каждой итерации

Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа

На разных фазах спирали разрабатываются основные концепции ПО

|Достоинства|Недостатки|
|---|---|
|Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
|Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|


## UML Диаграммы: Структурные и поведенческие

Основное значение - графическое представление различных аспектов разработки ПО

### UML
Графический язык моделирования общего назначения
Предназначен для:
- Спецификации
- Визуализации
- Проектированию и документированию артефактов

UML Диаграммы делятся на

##### Структурные
- Доменные модели
- Диаграммы развертывания

Нужны для 
- Статического описания системы
- Демонстрации архитектуры, конфигурации, специфических элементов предметной области

##### Поведенческие
- Диаграммы прецедентов использования 
	- Use-case диаграммы
	- Описывают высокоуровневые требования к системе
- Диаграммы последовательностей
	- Описывают последовательность алгоритма
- Диаграммы состояний
	- Описывают состояние системы

Представляют собой динамическую картину действий, происходящих в системе

##  11. UML: Use-case модель 
Поведенческая диаграмма

Отображает динамическое поведение в UML

Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов

**Actors** (акторы) - люди/организации, которые работают под определенными ролями внутри системы

**Use-case** - прецедент использования

**Association** - ассоциация, использование

**Include** - включение
- Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов

**Extend** - точка расширения функционала
- Указывает расширение от базового функционала

**Generalization** - обобщение
**System Boundary** - границы системы

## 12. UML: Диаграмма классов

Структурная диаграмма

- Представляет модель **статической структуры** программной системы
- Используется в **ООП** — терминология классов
- Отражает:
	- Взаимосвязи между сущностями предметной области (f.e. объекты и подсистемы)
	- Внутреннюю структуру объектов (f.e. поля, методы)
	- Типы отношений (наследование, реализация интерфейсов)
- Не включает информацию о **временных аспектах**
- Показывает **реализованную предметную область** в первом приближении

## 13. UML: Диаграмма последовательностей

Поведенческая диаграмма

- A.k.a. диаграмма конечных автоматов
- Отображает модель **конечных автоматов**
- Представляет собой набор **состояний и условий переходов** между ними

## 14. UML: Диаграмма размещения

Структурная диаграмма

- Отображает **физическую архитектуру** размещения ПО
- Описывает процесс **развертывания артефактов** по узлам

f.e.:

- Диаграмма с изображением серверной машины, на которой:
	- Крутится веб-сервер
	- Веб-сервер запускает JVM
	- В JVM работает микросервис
	- Отдельно изображена пользовательская машина с браузером

## 15. *UP методологии (90-е). RUP: основы процесса

- RUP — частный пример \*UP, основан на OOSE + OMT + метод Буча
- Инкрементно-эволюционный процесс
- Разработка разбита на **4 фазы**:
	1. Inception / Начало
	2. Elaboration / Проектирование
	3. Construction / Построение
	4. Transition / Внедрение
- Каждая фаза заканчивается **вехой** (milestone)
- Все роли явно описаны (около 30)
	- Роль = группа обязанностей одного участника
	- У каждой роли есть:
		- Набор деятельностей
		- Входы/выходы в виде артефактов (диаграммы, документы, код)
- Все процессы в RUP связаны между собой и **подробно описаны**
- Сам RUP — это HTML-энциклопедия, все элементы связаны гиперссылками

## 16. RUP: Фаза «Начало»

**Цели:**

1. Определить границы/области применения проекта
2. Описать основные сценарии использования
3. Предложить технологическое решение
4. Рассчитать стоимость и составить график работ
5. Оценить риски
6. Подготовить окружение

**Веха: Lifecycle Objectives**

- Оценка сроков
- Первоначальная стоимость
- Требования
- Приоритеты
- Технологии
- Стратегии смягчения рисков

## 17. RUP: Фаза «Проектирование»

**Цели:**

1. Финализировать архитектуру системы
2. Разработать архитектурные прототипы
3. Проверить стабильность архитектуры, планов и рисков

**Веха: Lifecycle Architecture**

- Требования, архитектура стабильны?
- Есть критерии тестирования прототипов?
- Тестирование прошло успешно?
- Планы разработки приемлемы по стоимости?
- Расходы соответствуют бюджету?
- Проект подтвержден всеми заинтересованными сторонами?

## 18. RUP: Фаза «Построение»

**Цели:**

1. Эффективно реализовать ПО
2. Провести итерации: анализ → проектирование → код → тест
3. Создать релизы (альфа, бета…)
4. Подготовить продукт к развертыванию

**Веха: Initial Operational Capability**

- Продукт стабилен для передачи заказчику?
- Готова принимающая сторона?
- Стоимость соответствует ожиданиям?

## 19. RUP: Фаза «Внедрение»

**Цели:**

1. Развернуть систему и БД на целевой платформе
2. Обучить пользователей
3. Запустить маркетинг, продажи
4. Отладить сбои, выкатить хотфиксы
5. Убедиться в самодостаточности пользователей
6. Провести анализ соответствия ожиданиям

**Веха: Release**

- Пользователи удовлетворены?
- Финальная стоимость приемлема?

## 20. Манифест Agile (2001)

4 ценности:
1. Люди и взаимодействие > процессов и инструментов
2. Работающий продукт > исчерпывающей документации
3. Сотрудничество с заказчиком > согласованного контракта
4. Готовность к изменениям > следования плану

## 21. Scrum

- **Бэклог** — основной артефакт
	- Продукт-бэклог: бизнес-требования
	- Спринт-бэклог: технические детали
- **Спринт** — итерация 1–4 недели
	- В конце — демонстрация заказчику
	- Каждые несколько спринтов — **ретроспектива**
	- Каждый день — **дейлик** (скрам-митинг)
		- Что сделано
		- Что планируется
- **Команда**: 3–10 человек
- **Роли**:
	- Продакт овнер
		- Формирует приоритеты бэклога
	- Скрам-мастер
		- Организует скрам-митинги
		- Планирует спринты
		- Разрешает конфликты

**Плюсы:**

- Простота
- Минимум бюрократии
- Максимум ценности

## 22. Disciplined Agile 2.X (2013)

- Гибрид RUP + Scrum
- Использует **инкрементальную модель** со спринтами

#### Из RUP:
- Фазы: Начало / Построение / Внедрение
- Описание ролей

#### Из Scrum:
- Спринты

### Новое в DAD:
- Архитектурное управление
- Переиспользование кода
- Управление персоналом
- Постоянное улучшение процесса

## 23. Требования. Иерархия требований

- Требование = описание того, что должно быть реализовано
- Не говорит **как** реализовать
- Не должно быть разночтений
- Документируются в **SRS**

### Иерархия:

1. Потребности (пользователь)
	- "Мне нужна сковорода, на которой не будет пригорать"
2. Функции (аналитик)
	- "Антипригарное покрытие, термоизолированная ручка"
3. Требования к ПО
	- "Диаметр 25см, бортики 5см, алюминиевый сплав АК7П"

## 24. Свойства и типы требований (FURPS+)

Используется в RUP

### Свойства требований:

- Корректность
- Однозначность
- Полнота
- Непротиворечивость
- Приоритизация
- Проверяемость
- Модифицируемость
- Отслеживаемость

### Типы требований:

- **F** — Functional (функциональные)
- **U** — Usability (удобство использования)
- **R** — Reliability (надежность)
- **P** — Performance (производительность)
- **S** — Supportability (поддержка)
- **+** — прочее:
	- Ограничения проектирования
	- Интерфейсы
	- Физические требования


## 25. Формулирование требований. Функциональные требования

Формат записи:
`<id> <система> должна / shall <требование>`

Функциональные требования — описывают **что система должна делать**.
### Примеры:
- Feature sets
	- Наборы функциональности
- Capabilities
	- Возможности системы
- Security
	- Требования к безопасности

## 26. Требования к удобству использования и надежности (Usability & Reliability)

### Usability (удобство использования)

1. Human Factors
	- Учет особенностей пользователей
		- e.g. плохое зрение, слух
2. Aesthetics
	- Эстетические требования (e.g. брендбук, оформление интерфейса)
3. Consistency in UI
	- Согласованность элементов пользовательского интерфейса
4. Online и context-sensitive help
	- Требования к справке:
		- Онлайн-доступ
		- Контекстная подсказка
5. Wizards и Agents
	- Программы, повышающие удобство:
		- Wizard — пошаговые мастера установки (куда ставить, ярлык, uninstaller)
		-  Agents — TODO: не понял что это, нужно уточнить 
6. User Documentation
	- Требования к документации для конечных пользователей
7. Training Materials
	- Учебные материалы (видео, презентации, интерактивные мануалы)

### Reliability (надежность)

1. Frequency and severity of failure
	- Частота и серьезность отказов
2. Recoverability
	- Способность системы **восстанавливаться** в случае отказа
3. Predictability
	- Предсказуемость поведения системы
4. Availability
	- Готовность к выполнению задач в нужный момент времени
5. Accuracy
	- Точность выполнения операций
6. MTBF (Mean Time Between Failures)
	- Среднее время между отказами


## 26. Требования к производительности и поддерживаемости.
## 27. Атрибуты требований.
## 28. Описание прецедента.
## 29. Риски. Типы Рисков.
## 30. Управления рисками. Деятельности, связанные с оценкой.
## 31. Управления рисками. Деятельности, связанные контролем и управлением.
## 32. Изменение. Общая модель управления изменениями.
## 33. Системы контроля версий. Одновременная модификация файлов.
## 34. Subversion. Архитектура системы и репозиторий.
## 35. Subversion: Основной цикл разработчика. Команды.
## 36. Subversion: Конфликты. Слияние изменений.
## 37. GIT: Архитектура и команды.
## 38. GIT: Организация ветвей репозитория.
## 39. GIT: Плагин git-flow.
## 40. Системы автоматической сборки: предпосылки появления
## 41. Системы сборки: Make и Makefile.
## 42. Системы сборки: Ant. Команды Ant.
## 43. Системы сборки: Ant-ivy.
## 44. Системы сборки: Maven. POM. Репозитории и зависимости.
## 45. Maven: Структура проекта. GAV.
## 46. Maven: Зависимости. Жизненный цикл сборки. Плагины.
## 47. Системы сборки: Maven. POM. Репозитории и зависимости.
## 48. Системы сборки: GNU autotools. Создание конфигурации проекта.50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
## 49. Сервера сборки/непрерывной интеграции.
## 50. Основные понятия тестирования. Цели тестирования.
## 51. Понятие полного тестового покрытия и его достижимости. Пример.
## 52. Статическое и динамическое тестирование.
## 53. Автоматизация тестов и ручное тестирование.
## 54. Источники данных для тестирования. Роли и деятельности в тестировании.
## 55. Понятие тестового случая и сценария.
## 56. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
## 57. Модульное тестирование. Junit 4.
## 58. Интеграционное тестирование. Стратегии интеграции.
## 59. Функциональное тестирование. Selenium.
## 60. Техники статического тестирования. Статический анализ кода.
## 61. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
## 62. Тестирование системы в целом. Альфа- и бета-тестирование.
## 63. Аспекты быстродействия системы. Влияние средств измерения на результаты.
## 64. Ключевые характеристики производительности.
## 65. Нисходящий метод поиска узких мест.
## 66. Пирамида памяти и ее влияние на производительность.
## 67. Мониторинг производительности: процессы.
## 68. Мониторинг производительности: виртуальная память.
## 69. Мониторинг производительности: буферизированный файловый ввод-вывод.
## 70. Мониторинг производительности: Windows и Linux.
## 71. Системный анализ Linux "за 60 секунд".
## 72. Создание тестовой нагрузки и нагрузчики.
## 73. Профилирование приложений. Основные подходы.
## 74. Компромиссы (trade-offs) в производительности.
## 75. Рецепты повышения производительности при высоком %SYS.
## 76. Рецепты повышения производительности при высоком %IO wait.
## 77. Рецепты повышения производительности при высоком %Idle.
## 78. Рецепты повышения производительности при высоком %User.
