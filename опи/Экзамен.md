## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ. 

Жизненный цикл ПО: 

- Разработка требований (заказчик, программисты)
- Анализ
- Проектирование архитектуры
- Разработка
- Тестирование
- Внедрение в эксплуатацию
- Эксплуатация (багфиксы, поддержка пользователей, обновления)
- Вывод из эксплуатации
	- Сохранность накопленных файлов
	- Миграция на новое ПО

Группы ЖЦ ПО: 

1. Процесс согласования (2)
2. Процесс организационного обеспечения (5)
3. Процессы проекта (7)
4. Технологические процессы (11)
5. Процесс реализации программного средства (7)
6. Процесс поддержки ПС (8)
7. Процесс повторного использования ПС

## 2. Модели ЖЦ (последовательная, инкрементная, эволюционная)

#### Последовательная 
-  A.k.a. однократная, waterfall
-  Определены все требования, один этап разработки
-  Один последовательный проход
-  Получившиеся результаты окончательны и, как правило, не подлежат пересмотру

#### Инкрементнеая
- Определены не все требования
- Разрабатывается прототип, который с течением времени развивается

###### Сравнение стратегий
|Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
|---|----|----|---|
|Последовательная|Да|Нет|Нет|
|Инкрементная|Да|Да|Maybe|
|Эволюционная|Нет|Да|Да|

## 3. Водопадная (каскадная) модель
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcgj2PIgMq0q2Jhji2fL1A6NOf8alPM-GHervvvjrMAcLqkf2DINsZiu5lkalI72crfZSFaSRiID0-zVDM9NfU0Zq0DtSb2a7l_FH7RBAkbzG54EILaX0k9zfK2l-7E2WpghTykpf4mc_9QPT-h-3xhkCQY?key=1pD2kcEQ8Lrk26WoBNVmmQ)


- Разработана в 60-х
- Описана ройсом в 70-х

**Суть** в том, что есть 7 фаз раработки ПО, которые идут друг за другом только, и только в этом порядке и между ними есть итерации:

1. Сбор требований к системе
2. Сбор требований к ПО
3. Анализ требований
4. Проектирование дизайна ПО
5. Кодирование
6. Тестирование
7. Эксплуатация

- Можно откатиться к предыдущей фазе, но это сложно и не особо предусмотрено, так как потенциально это может привести к двухкратному росту сроков и стоимости разработки

|Плюсы|Минусы|
|---|---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
|Автоматизация отдельных несвязных задач|Позднее тестирование|

## 4. Методология Ройса
Водопад, но с дополнительными шагами
 
 1. Предварительный дизайн - между программными требованиями и анализом
	 - Программисты и аналитики не допускаются
	 - На этом этапе предполагается спроектировать, определить и создать модель обработки данных, а так же создать документ-обзор системы
2. Написание документации для всей системы
	- Требования к системе
	- Спецификация предварительного дизайна
	- Спецификация дизайна интерфейсов
	- Финальная спецификация дизайна системы
	- План тестирования
	- Инструкция пользовательской эксплуатации
3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа характеристик ПО
4. Тестирование с привлечением независимых экспертов
	- Наиболее рисковая фаза с точки зрения денег и сроков
5. Несколько этапов подключения пользователей
	- Предварительный
	- Критический
	- Финальный просмотр


## 5. Традиционная V-chart model J. Munson, B.Boehm

Та же последовательность действий, что и в водопаде, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирования

Определяются следующие этапы:
1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка  
2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении  
3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование  
4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование  
5. Кодирование $\leftrightarrow$ Юнит-тестирование  

## 6. Многопроходная модель (Incremental model)
**Частный случай V-chart модели**

Параллельная разработка частей продукта, а в последствии интегрирование воедино
- На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя
	- Детальное проектирование
	- Кодирование
	- Интеграция протот

Снижение стоимости внесения изменений

Возможность использования частично разработанной системы

Имеет тенденцию к устареванию, деградации
- Соответственно требует рефакторинга с течением времени

При параллельной разработке несколькими командами требует стабильного API

Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно

Из-за всех факторов, сложно оценивать стоимость разработки ПО

## 7. Модель прототипирования (80-е)
![[Прототипирование.png]]  
#### Суть
##### Фазы:
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
- Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками 
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованием

3. Конструирование
- На этом этапе происходит разработка программ и приложений
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсия данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить:
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
-  Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 8. RAD методология
![[RAD.png]]

RAD - Rapid Application Dev Model - Быстрая разработка приложение

Порождена IBM в 80-х, обнародована в 1991
Разновидность инкрементной модели
Пользователь принимает непосредственное участие в процессе разработки
Временные рамки одного цикла **жестко** ограничены

#### Суть

##### Фазы
1. Планирование
- Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
-  Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение

2. Пользовательское проектирование
- Пользователи взаимодействуют с системными аналитиками
- Разрабатывают модели и прототипы
- Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям

3. Конструирование
- На этом этапе происходит разработка программ и приложений 
- Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов

4. Переключение
- Конверсию данных
- Тестирование
- Переход на новую систему
- Тренировку пользователей

##### Позволяет обеспечить
- Быстроту продвижения програмнного продукта на рынок
- Интерфейс, устраивающий пользователя
- Легкую адаптируемость проекта к изменяющимся требованиям
- Простоту развития функциональности системы

## 9. Спиральная модель
По сути - это совмещение прототипной модели + куча тестирования из V-chart модели

Особое внимание уделяется управлению рисками
- Вследствие, специфический анализ на каждой итерации

Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа

На разных фазах спирали разрабатываются основные концепции ПО

|Достоинства|Недостатки|
|---|---|
|Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
|Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|


## 10. UML Диаграммы: Структурные и поведенческие

Основное значение - графическое представление различных аспектов разработки ПО

### UML
Графический язык моделирования общего назначения
Предназначен для:
- Спецификации
- Визуализации
- Проектированию и документированию артефактов

UML Диаграммы делятся на

##### Структурные
- Доменные модели
- Диаграммы развертывания

Нужны для 
- Статического описания системы
- Демонстрации архитектуры, конфигурации, специфических элементов предметной области

##### Поведенческие
- Диаграммы прецедентов использования 
	- Use-case диаграммы
	- Описывают высокоуровневые требования к системе
- Диаграммы последовательностей
	- Описывают последовательность алгоритма
- Диаграммы состояний
	- Описывают состояние системы

Представляют собой динамическую картину действий, происходящих в системе

##  11. UML: Use-case модель 
Поведенческая диаграмма

Отображает динамическое поведение в UML

Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов

**Actors** (акторы) - люди/организации, которые работают под определенными ролями внутри системы

**Use-case** - прецедент использования

**Association** - ассоциация, использование

**Include** - включение
- Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов

**Extend** - точка расширения функционала
- Указывает расширение от базового функционала

**Generalization** - обобщение
**System Boundary** - границы системы

## 12. UML: Диаграмма классов

Структурная диаграмма

- Представляет модель **статической структуры** программной системы
- Используется в **ООП** — терминология классов
- Отражает:
	- Взаимосвязи между сущностями предметной области (f.e. объекты и подсистемы)
	- Внутреннюю структуру объектов (f.e. поля, методы)
	- Типы отношений (наследование, реализация интерфейсов)
- Не включает информацию о **временных аспектах**
- Показывает **реализованную предметную область** в первом приближении

## 13. UML: Диаграмма последовательностей

Поведенческая диаграмма

- A.k.a. диаграмма конечных автоматов
- Отображает модель **конечных автоматов**
- Представляет собой набор **состояний и условий переходов** между ними

## 14. UML: Диаграмма размещения

Структурная диаграмма

- Отображает **физическую архитектуру** размещения ПО
- Описывает процесс **развертывания артефактов** по узлам

f.e.:

- Диаграмма с изображением серверной машины, на которой:
	- Крутится веб-сервер
	- Веб-сервер запускает JVM
	- В JVM работает микросервис
	- Отдельно изображена пользовательская машина с браузером

## 15. *UP методологии (90-е). RUP: основы процесса

- RUP — частный пример \*UP, основан на OOSE + OMT + метод Буча
- Инкрементно-эволюционный процесс
- Разработка разбита на **4 фазы**:
	1. Inception / Начало
	2. Elaboration / Проектирование
	3. Construction / Построение
	4. Transition / Внедрение
- Каждая фаза заканчивается **вехой** (milestone)
- Все роли явно описаны (около 30)
	- Роль = группа обязанностей одного участника
	- У каждой роли есть:
		- Набор деятельностей
		- Входы/выходы в виде артефактов (диаграммы, документы, код)
- Все процессы в RUP связаны между собой и **подробно описаны**
- Сам RUP — это HTML-энциклопедия, все элементы связаны гиперссылками

## 16. RUP: Фаза «Начало»

**Цели:**

1. Определить границы/области применения проекта
2. Описать основные сценарии использования
3. Предложить технологическое решение
4. Рассчитать стоимость и составить график работ
5. Оценить риски
6. Подготовить окружение

**Веха: Lifecycle Objectives**

- Оценка сроков
- Первоначальная стоимость
- Требования
- Приоритеты
- Технологии
- Стратегии смягчения рисков

## 17. RUP: Фаза «Проектирование»

**Цели:**

1. Финализировать архитектуру системы
2. Разработать архитектурные прототипы
3. Проверить стабильность архитектуры, планов и рисков

**Веха: Lifecycle Architecture**

- Требования, архитектура стабильны?
- Есть критерии тестирования прототипов?
- Тестирование прошло успешно?
- Планы разработки приемлемы по стоимости?
- Расходы соответствуют бюджету?
- Проект подтвержден всеми заинтересованными сторонами?

## 18. RUP: Фаза «Построение»

**Цели:**

1. Эффективно реализовать ПО
2. Провести итерации: анализ → проектирование → код → тест
3. Создать релизы (альфа, бета…)
4. Подготовить продукт к развертыванию

**Веха: Initial Operational Capability**

- Продукт стабилен для передачи заказчику?
- Готова принимающая сторона?
- Стоимость соответствует ожиданиям?

## 19. RUP: Фаза «Внедрение»

**Цели:**

1. Развернуть систему и БД на целевой платформе
2. Обучить пользователей
3. Запустить маркетинг, продажи
4. Отладить сбои, выкатить хотфиксы
5. Убедиться в самодостаточности пользователей
6. Провести анализ соответствия ожиданиям

**Веха: Release**

- Пользователи удовлетворены?
- Финальная стоимость приемлема?

## 20. Манифест Agile (2001)

4 ценности:
1. Люди и взаимодействие > процессов и инструментов
2. Работающий продукт > исчерпывающей документации
3. Сотрудничество с заказчиком > согласованного контракта
4. Готовность к изменениям > следования плану

## 21. Scrum

- **Бэклог** — основной артефакт
	- Продукт-бэклог: бизнес-требования
	- Спринт-бэклог: технические детали
- **Спринт** — итерация 1–4 недели
	- В конце — демонстрация заказчику
	- Каждые несколько спринтов — **ретроспектива**
	- Каждый день — **дейлик** (скрам-митинг)
		- Что сделано
		- Что планируется
- **Команда**: 3–10 человек
- **Роли**:
	- Продакт овнер
		- Формирует приоритеты бэклога
	- Скрам-мастер
		- Организует скрам-митинги
		- Планирует спринты
		- Разрешает конфликты

**Плюсы:**

- Простота
- Минимум бюрократии
- Максимум ценности

## 22. Disciplined Agile 2.X (2013)

- Гибрид RUP + Scrum
- Использует **инкрементальную модель** со спринтами

#### Из RUP:
- Фазы: Начало / Построение / Внедрение
- Описание ролей

#### Из Scrum:
- Спринты

### Новое в DAD:
- Архитектурное управление
- Переиспользование кода
- Управление персоналом
- Постоянное улучшение процесса

## 23. Требования. Иерархия требований

- Требование = описание того, что должно быть реализовано
- Не говорит **как** реализовать
- Не должно быть разночтений
- Документируются в **SRS**

### Иерархия:

1. Потребности (пользователь)
	- "Мне нужна сковорода, на которой не будет пригорать"
2. Функции (аналитик)
	- "Антипригарное покрытие, термоизолированная ручка"
3. Требования к ПО
	- "Диаметр 25см, бортики 5см, алюминиевый сплав АК7П"

## 24. Свойства и типы требований (FURPS+)

Используется в RUP

### Свойства требований:

- Корректность
- Однозначность
- Полнота
- Непротиворечивость
- Приоритизация
- Проверяемость
- Модифицируемость
- Отслеживаемость

### Типы требований:

- **F** — Functional (функциональные)
- **U** — Usability (удобство использования)
- **R** — Reliability (надежность)
- **P** — Performance (производительность)
- **S** — Supportability (поддержка)
- **+** — прочее:
	- Ограничения проектирования
	- Интерфейсы
	- Физические требования


## 25. Формулирование требований. Функциональные требования

Формат записи:
`<id> <система> должна / shall <требование>`

Функциональные требования — описывают **что система должна делать**.
### Примеры:
- Feature sets
	- Наборы функциональности
- Capabilities
	- Возможности системы
- Security
	- Требования к безопасности

## 26. Требования к удобству использования и надежности (Usability & Reliability)

### Usability (удобство использования)

1. Human Factors
	- Учет особенностей пользователей
		- e.g. плохое зрение, слух
2. Aesthetics
	- Эстетические требования (e.g. брендбук, оформление интерфейса)
3. Consistency in UI
	- Согласованность элементов пользовательского интерфейса
4. Online и context-sensitive help
	- Требования к справке:
		- Онлайн-доступ
		- Контекстная подсказка
5. Wizards и Agents
	- Программы, повышающие удобство:
		- Wizard — пошаговые мастера установки (куда ставить, ярлык, uninstaller)
		-  Agents — TODO: не понял что это, нужно уточнить 
6. User Documentation
	- Требования к документации для конечных пользователей
7. Training Materials
	- Учебные материалы (видео, презентации, интерактивные мануалы)

### Reliability (надежность)

1. Frequency and severity of failure
	- Частота и серьезность отказов
2. Recoverability
	- Способность системы **восстанавливаться** в случае отказа
3. Predictability
	- Предсказуемость поведения системы
4. Availability
	- Готовность к выполнению задач в нужный момент времени
5. Accuracy
	- Точность выполнения операций
6. MTBF (Mean Time Between Failures)
	- Среднее время между отказами
## 27. Требования к производительности и поддерживаемости.


Производительность определяются
- Speed — скорость решения задач
- Efficiency — эффективность
- Availability — готовность системы к решению задач
- Throughput — пропускная способность
- Response time — время отклика
- Recovery time — время восстановления
- Resource usage — использование системных (и других) ресурсов
Поддерживаемость определяются
- Extensibility — расширяемость
- Adaptability — адаптируемость
- Maintainability — поддерживаемость
- Compatibility — совместимость
- Configurability — способность задавать конкретную конфигурацию
- Serviceability — возможность проведения профилактики и обслуживания
- Installability — требования к установке на разные системы
- Localizability — локализуемость для разных языков и географических регионов.
## 28. Атрибуты требований.

1. Приоритет - MoSCoW
	1. MUST have
		- Фундаментальные для системы требования
	2. Should have
		- Важные
	3. Could have
		- Потенциально возможные, улучшающие
		- e.g.: пользовательское соглашение
	4. Won't have
		- Возможно в следующей версии
2. Статус
	1. Предложенные
	2. Одобренные
	3. Отклоненные
	4. Включенные
3. Трудоемкость
	1. Человеко-часы
	2. Функциональные точки
	3. Use-case points
	4. Попугаи
		1. Один попуг - это некое эталонное функциональное требование, которое выполняется средним человеком в команде
		2. Время, потраченное на данную работу принимается за одного попуга
		3. Все остальные требования отсчитываются относительно эталонного попугая
4. Риск
5. Стабильность
	1. Высокая
	2. Средняя
	3. Низкая
6. Целевая версия
	1. "Когда включим в продукт?"

## 29. Описание прецедента.

Прецеденты/cases могут быть описаны в виде сценариев/user story

В дальнейшем разработчики зачастую анализируют не требования, а сценарии

| Прецедент             | Описание                                           |
| --------------------- | -------------------------------------------------- |
| ID                    | Номер                                              |
| Краткое описание      | Пользователь хочет просмотреть новостную статью    |
| Главные акторы        | Пользователь                                       |
| Второстепенные акторы | Опциональны (в данном случае нет)                  |
| Предусловия           | Пользователь увидел интересующую статью            |
| Основной поток        | Пользователь переходит на одну из возможных статей |
| Альтернативный поток  | Опционален (отсутствует в данном случае)           |
| Постусловия           | Система показывает пользователю новостную статью   |

## 30. Риски. Типы Рисков.


Риск - это
 - Потенциально опасный для проекта фактор
 - Влияние неопределенности на цели
 - Сочетание вероятности события и его (негативных) последствий

Типы рисков:
1. Прямые
	1. Можем управлять, контролировать риск
2. Непрямые
    -  не можем((

Типы рисков:
1. Ресурсные
	- Организационные, финансовые, люди, время
	- Управляемые риски, так как возможно изменение выделяемых ресурсов
2. Бизнес-риски
    - Конкуренция, подрядчики, убыточность решения
    - Сложно поддается управлению со стороны разработчиков
3. Технические риски
    - Компетенции разработчиков в применяемых технологиях
4. Политические риски
	 - Сферы влияния менеджеров
	 - 
5. Форс-мажор
    - [фр.](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B0%D0%BD%D1%86%D1%83%D0%B7%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Французский язык") force majeure — «_высшая сила_»
    - e.g.: стихийные бедствия, война, изменение законодательства)) и т.д.


## 31. Управления рисками. Деятельности, связанные с оценкой.

## 32. Управления рисками. Деятельности, связанные с контролем и управлением.

## 33. Изменение. Общая модель управления изменениями.

## 34. Системы контроля версий. Одновременная модификация файлов.

## 35. Subversion‌. Архитектура системы и репозиторий.

## 36. Subversion‌: Основной цикл разработчика. Команды.

## 37. Subversion‌: Конфликты. Слияние изменений.

## 38. GIT: Архитектура и команды.

## 39. GIT: Организация ветвей репозитория.

## 40. GIT: Плагин git-flow.

## 41. Системы автоматической сборки: предпосылки появления.

## 42. Системы сборки: Make и Makefile (РАСПРАВА).

## 44. Системы сборки: Ant-ivy.

## 45. Системы сборки: Maven. POM. Репозитории и зависимости.

## 46. Maven: Структура проекта. GAV.

## 47. Maven: Зависимости. Жизненный цикл сборки. Плагины.

## 48. Системы сборки: Gradle. Преимущества и файл сборки.

## 49. Системы сборки: GNU autotools. Создание конфигурации проекта.

## 50. Системы сборки: GNU autotools
## 51. Сервера сборки/непрерывной интеграции.

## 52. Основные понятия тестирования. Цели тестирования.

## 53. Понятия полного тестового покрытия и его достижимости. Пример.

## 54. Статическое и динамическое тестирование.

## 55. Автоматизация тестов и ручное тестирование.

## 56. Источники данных для тестирования. Роли и деятельности в тестировании.

## 57. Понятие тестового случая и сценария.

## 58. Выбор тестового покрытия и количества тестов.

## 59. Модульное тестирование. JUnit 4.

## 60. Интеграционное тестирование. Стратегии интеграции.

## 61. Функциональное тестирование. Selenium.

## 62. Техники статического тестирования. Статический анализ кода.

## 63. Тестирование системы в целом. Системное тестирование. Тестирование производительности.

## 64. Тестирование системы в целом. Альфа- и бета- тестирование.

## 65. Аспекты быстродействия системы. Влияние средств измерения на результаты.

## 66. Ключевые характеристики производительности.

## 67. Нисходящий метод поиска узких мест.

## 68. Пирамида памяти и ее влияние на производительность.

## 69. Мониторинг производительности: процессы.

## 70. Мониторинг производительности: виртуальная память.

## 71. Мониторинг производительности: буферизированный файловый ввод-вывод.

## 72. Мониторинг производительности: Windows и Linux.

## 73. Системный анализ Linux "за 60 секунд".

## 74. Создание тестовой нагрузки и нагрузчики.

## 75. Профилирование приложений. Основные подходы.

## 76. Компромиссы (trade-offs) в производительности.

## 77. Рецепты повышения производительности при высоком %SYS.

## 78. Рецепты повышения производительности при высоком %IO wait.

## 79. Рецепты повышения производительности при высоком %Idle.

## 80. Рецепты повышения производительности при высоком %User.
1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ
2. Модели ЖЦ (последовательная, инкрементная, эволюционная).
3. Водопадная (каскадная) модель.
4. Методология Ройса.
5. Традиционная V-chart model J.Munson, B.Boehm.
6. Многопроходная модель (Incremental model).
7. Модель прототипирования (80-е).
8. RAD методология.
9. Спиральная модель.
10. UML Диаграммы: Структурные и поведенческие.
11. UML: Use-case модель.
12. UML: Диаграмма классов.
13. UML: Диаграмма последовательностей
14. UML: Диаграмма размещения
15. \*UP методологии (90-е). RUP: основы процесса.
16. RUP: Фаза «Начало».
17. RUP: Фаза «Проектирование».
18. RUP: Фаза «Построение».
19. RUP: Фаза «Внедрение».
20. Манифест Agile (2001).
21. Scrum.
22. Disciplined Agile 2.X (2013).
23. Требования. Иерархия требований.
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.
41. Системы автоматической сборки: предпосылки появления
42. Системы сборки: Make и Makefile.
43. Системы сборки: Ant. Команды Ant.
44. Системы сборки: Ant-ivy.
45. Системы сборки: Maven. POM. Репозитории и зависимости.
46. Maven: Структура проекта. GAV.
47. Maven: Зависимости. Жизненный цикл сборки. Плагины.
48. Системы сборки: Maven. POM. Репозитории и зависимости.
49. Системы сборки: GNU autotools. Создание конфигурации проекта.50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
50. Сервера сборки/непрерывной интеграции.
51. Основные понятия тестирования. Цели тестирования.
52. Понятие полного тестового покрытия и его достижимости. Пример.
53. Статическое и динамическое тестирование.
54. Автоматизация тестов и ручное тестирование.
55. Источники данных для тестирования. Роли и деятельности в тестировании.
56. Понятие тестового случая и сценария.
57. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
58. Модульное тестирование. Junit 4.
59. Интеграционное тестирование. Стратегии интеграции.
60. Функциональное тестирование. Selenium.
61. Техники статического тестирования. Статический анализ кода.
62. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
63. Тестирование системы в целом. Альфа- и бета-тестирование.
64. Аспекты быстродействия системы. Влияние средств измерения на результаты.
65. Ключевые характеристики производительности.
66. Нисходящий метод поиска узких мест.
67. Пирамида памяти и ее влияние на производительность.
68. Мониторинг производительности: процессы.
69. Мониторинг производительности: виртуальная память.
70. Мониторинг производительности: буферизированный файловый ввод-вывод.
71. Мониторинг производительности: Windows и Linux.
72. Системный анализ Linux "за 60 секунд".
73. Создание тестовой нагрузки и нагрузчики.
74. Профилирование приложений. Основные подходы.
75. Компромиссы (trade-offs) в производительности.
76. Рецепты повышения производительности при высоком %SYS.
77. Рецепты повышения производительности при высоком %IO wait.
78. Рецепты повышения производительности при высоком %Idle.
79. Рецепты повышения производительности при высоком %User.



asd
1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ
	1.  Жизненный цикл - время существования программы от момента замысла до вывода ее из эксплуатации. Все этапы жизненного цикла описаны в ISO
	2. Существуют 8 основных этапов:
		1. Разработка требования
		2. Анализ
		3. Проектирование архитектуры
		4. Разработка
		5. Тестирование 
		6. Внедрение в эксплуатацию
		7. Эксплуатация
			1. В эксплуатацию входят:
				1. Багфиксы
				2. Поддержка пользователей
				3. Обновления
		8. Вывод из эксплуатации
			1. В этот этап входят:
				1. Сохранность накопленных файлов 
				2. Миграция на новое ПО
	3. Существуют 7 групп ЖЦ ПО:
		1. Процесс согласования
		2. Процесс организации обеспечения
		3. Процессы проекта
		4. Технологические процессы
		5. Процесс реализации программного средства
		6. Процесс поддержки программных средств
		7. Процесс повторного использования программных средств
2. Модели ЖЦ (последовательная, инкрементная, эволюционная).
	1. Последовательная 
		1. A.k.a. однократная, waterfall
		2. Определены все требования, один этап разработки
		3. Один последовательный проход
		4. Получившиеся результаты окончательны и, как правило, не подлежат пересмотру
	2. Инкрементная
		1. Определены все требования, несколько этапов
		2. Система разрабатывается по частям и для каждой части производятся все этапы жизненного цикла
	3. Эволюционная
		1. Определены не все требования
		2. Разрабатывается прототип, который с течением времени развивается
	4. |Стратегия разработки|В начале процесса определены все требования?|Множество циклов разработки?|Промежуточное ПО распространяется?|
	   |---|----|----|---|
	   |Последовательная|Да|Нет|Нет|
	   |Инкрементная|Да|Да|Maybe|
	   |Эволюционная|Нет|Да|Да|
3. Водопадная (каскадная) модель.
	1. Разработана в 60-х
	2. Описана Ройсом в 70-х
	3. Суть в том, что есть 7 фаз разработки ПО, которые идут друг за другом только, и только в этом порядке, и есть итерации между ними:
		1. Сбор требований к системе
		2. Сбор требований к ПО
		3. Анализ требований
		4. Проектирование дизайна ПО
		5. Кодирование
		6. Тестирование
		7. Эксплуатация системы
	4. Можно откатится к предыдущей фазе, но это сложно и не особо предусмотренно, так как потенциально это может привести к двукратному росту сроков и стоимости разработки
	5. |Плюсы|Минусы|
	   |---|---|
	   |Хорошие показатели по срокам разработки и надежности при решении отдельных задач|Неприменимость к большим и слоэным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
	   |Автоматизация отдельных несвязных задач|Позднее тестирование|
4. Методология Ройса.
	1. //todo: загрузить картинку, но учить я ее не буду нахуй надо
	2. По сути - те же яйца, только в профиль (с доп шагами)
	3. Описаны следующие шаги:
		1. Предварительный дизайн - между программными требованиями и анализом
			1. Программисты и аналитики не допускаются
			2. На этом шаге предполагается спроектировать, определить и создать модель обработки данных, а также создать документ-обзор системы
			3. 
		2. Написание документации для всей системы:
			1. Требования к системе
			2. Спецификация предварительного дизайна
			3. Спецификация дизайна интерфейсов
			4. Финальная спецификация дизайна системы
			5. План тестирования
			6. Инструкция пользовательской эксплуатации
		3. Параллельная разработка тестовой версии с укороченным временем разработки для анализа основных характеристик ПО
		4. Тестирование с привлечением независимых экспертов
			1. Наиболее рискованная фаза с точки зрения денег и сроков
		5. Несколько этапов подключения пользователей:
			1. Предварительный
			2. Критический
			3. Финальный просмотр
5. Традиционная V-chart model J.Munson, B.Boehm.
	1. Та же последовательность действий, что и в водопадике, но ее изогнули в форме V, сопоставив с почти каждой фазой из каскадной модели соответствующее тестирование
	2. Определяются следующие этапы:
		1. Сбор требований к системе $\leftrightarrow$ Использование и поддержка
		2. Сбор требований к ПО $\leftrightarrow$ Установка системы в конечном окружении
		3. Дизайн продукта $\leftrightarrow$ Приемочное тестирование
		4. Детализация дизайна $\leftrightarrow$ Системное и интеграционное тестирование
		5. Кодирование $\leftrightarrow$ Юнит-тестирование
6. Многопроходная модель (Incremental model).
	1. Частный случай V-chart модели
	2. Параллельная разработка частей продукта, а в последствии интегрирование воедино
		1. На этапе разработки происходит вместо одного этапа несколько, каждый включает в себя:
			1. Детальное проектирование
			2. Кодирование
			3. Интеграция протот
	3. Снижение стоимости внесения изменений
	4. Возможность использования частично разработанной системы
	5. Имеет тенденцию к устареваниюю, деградации
		1. Соответственно, требует рефакторинга с течением времени
	6. При параллельной разработке несколькими командами требует стабильного API, спланированного заранее
	7. Из-за высокой скорости изменений поддерживать документацию в больших проектах становится достаточно сложно
	8. Из-за всех факторов, сложно оценивать стоимость разработки ПО
7. Модель прототипирования (80-е).
	1. ![[Pasted image 20250612180036.png]]
	2. В чем суть:
		1. Быстро планируем всю итерацию
		2. Быстро анализируем требования и подходы к реализации
		3. Разрабатываем прототип
		4. Показываем заказчику
		5. Если заказчик одобряет, то:
			1. Разрабатываем окончательную версию ПО
			2. Тестируем
			3. Внедряем ПО
			4. Сопровождаем
			5. В ином случае:
				1. Переходим к третьему шагу (разработке прототипа), пока заказчик не скажет что его все устраивает
8. RAD методология.
	1. ![[Pasted image 20250612184140.png]]
	2. RAD - Rapid Application Dev Model - Быстрая разработка приложений
	3. Порождена IBM в 80-х, обнародована в 1991
	4. Разновидность инкрементной модели
	5. Пользователь принимает непосредственное участие в процессе разработки
	6. Временные рамки одного цикла **жестко** ограничены
	7. 
	8. В чем суть:
	9. Фазы:
		1. Планирование
			1. Пользователи, менеджеры и программисты обсуждают задачи проекта, объем, системные требования, потенциальные сложности
			2. Завершается согласование ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение
		2. Пользовательское проектирование
			1. На этом этапе:
				1. Пользователи взаимодействуют с системными аналитикам
				2. Разарабатывают модели и прототипы
			2. Длинный интерактивный процесс, который позволяет пользователям понять, изменить и в конечном счете выбрать рабочую модель, отвечающую их требованиям
		3. Конструирование
			1. На этом этапе происходит разработка программ и приложений
			2. Пользователи по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов
		4. Переключение
			1. Включает в себя:
				1. Конверсию данных
				2. Тестирование
				3. Переход на новую систему
				4. Тренировку пользователей
	10. Позволяет обеспечить:
		1. Быстроту продвижения програмнного продукта на рынок
		2. Интерфейс, устраивающий пользователя
		3. Легкую адаптируемость проекта к изменяющимся требованиям
		4. Простоту развития функциональности системы
9. Спиральная модель.
	1. По сути - это совмещение прототипной модели + куча тестирования из V-chart модели
	2. Особое внимание уделяется управлению рисками
		1. Вследствии, специфический анализ на каждой итерации
	3. Каждый виток спирали - одна фаза разработки продукта, которая предназначена для разработки очередной версии ПО или прототипа
	4. На разных фазах спирали разрабатываются основные концепции ПО
	5. |Достоинства|Недостатки|
	   |---|---|
	   |Изменения - неотъемлимая часть разработки|Разработка может оказаться затратной|
	   |Особое внимание уделяется управлению рисками|Не подходит для маленьких проектов|
10. UML Диаграммы: Структурные и поведенческие.
	1. Если кратко - то основное значение - графическое представление различных аспектов разработки ПО
	2. UML - графический язык моделирования общего назначения
		1. Предназначен для:
			1. Спецификации
			2. Визуализации
			3. Проектированию и документированию артефактов
	3. UML-диаграммы делятся на:
		1. Структурные
			1. К ним относятся:
				1. Доменные модели
				2. Диаграммы развертывания
			2. Нужны для:
				1. Статического описания системы
				2. Демонстрации архитектуры, конфигурации, специфических элементов предметной области
		2. Поведенческие
			1. К ним относятся:
				1. Диаграммы прецедентов использования
					1. a.k.a. Use-case диаграммы
					2. Описывают высокоуровневые требования к системе
				2. Диаграммы последовательностей
					1. Описывают последовательность алгоритма
				3. Диаграммы состояний
					1. Описывают состояния системы
			2. Представляют собой динамическую картину действий, происходящих в системе
11. UML: Use-case модель.
	1. Поведенческая диаграмма
	2. Отображает динамическое поведение в UML
	3. Моделирует функциональность системы с использованием участников/прецедентов/других важнейших объектов
	4. Actors (акторы) - люди/организации, которые работают под определенными ролями внутри системы
	5. Use-case - прецедент использования
	6. Association  - ассоциация, использование
	7. Include - включение
		1. Организует иерархию прецедентов и позволяет включать одну общую деятельность в несколько Use-Case'ов
	8. Extend - точка расширения функционала
		1. Указывает расширение от базового функционала
	9. Generalization - обобщение
	10. System Boundary - границы системы
12. UML: Диаграмма классов.
	1. Диаграмма, предназначенная для представления модели статической структуры программной системы в терминологии классов объектно-ориентированного программирования
	2. Может отражать:
		1. Различные взаимосвязи между отдельными сущностями предметной области
			1. f.e.: объекты и подсистемы
		2. Внутреннюю структуру объектов 
			1. f.e.: моля, методы
		3. Типы отношений
			1. Наследование, реализация интерфейсов
	3. Не указывается информация о временных аспектах функционирования системы
	4. Является примером структурной диаграммы 
	5. Отображает в первом приближении реализованную предметную область
13. UML: Диаграмма последовательностей
	1. a.k.a. диаграмма последовательностей a.k.a. диаграмма конечных автоматов
	2. Поведенческая диаграмма
	3. Отображает модель конечных автоматов
	4. Представляет собой набор состояний и условий переходов между ними
14. UML: Диаграмма размещения
	1. В контексте UML развертывание - это процесс распределения артефактов по узлам или экземпляров артефактов по экземплярам узлов
	2. Является примером структурной диаграммы
	3. Отображает физическую архитектуру размещения ПО + возможности его использования
	4. f.e.:
		1. Диаграмма с нарисованной серверной машиной, на которую крутится веб-сервер с JVM, в которой крутится микросервис плюс где то нарисована пользовательская машина с браузером 
15. \*UP методологии (90-е). RUP: основы процесса.
	1. RUP был построен на базе процесса OOSE и включил в себя элементы из процессов OMT, OOSE и метода Буча, которыми занимались в то время его создатели
	2.  \*UP идеи берут за собой идею о создании четкой унифицированной структуры создания ПО, подходящего для любой команды людей, позволяющей создать с ее помощью любой программный продукт
	3. Частный пример \*UP - RUP
	4. Разработка представляет из себя инкрементно-эволюционный процесс
	5. Разработка разбита на фазы
	6. Дисциплина - набор правил и указаний, необходимых для решения определенной задачи
	7. Цель этой методологии - конкретезировать действия разработчиков для того, чтобы максимально избежать сюрпризов и конкретезировать процесс разработки
	8. Всего существует 4 фазы:
		1. Interception/Начало
		2. Elaboration/Проектирование
		3. Construction/Построение
		4. Transtion/Внедрение
	9. Явно описаны все роли, которые принимают участие в создании ПО (около 30 ролей)
		1. Роль - группа обязанностей, которую берет на себя определенный участник команды
			1. У каждой роли есть набор деятельностей
			2. На входе и выходе деятельности используются, создаются и модифицируются артефакты
				1. Артефакты - любой результат труда роли, e.g. диаграмма, документ, программный код и пр.
			3. Деятельность четко регламентирована
	10. В отличии от других моделей жизненного цикла, в RUP каждый процесс детально описан и связан с другими процессами
	11. Любая фаза в RUP заканчивается вехами
		1. Веха - момент времени для принятия решения о дальнейших действиях, то есть либо переход на следующую фазу, либо проведение дополнительных работ на данной фазе
		2. Решение принимается заинтересованными лицами/стейкхолдеры (инвесторы, руководство высшего звена, исполнители работ)
			1. Обычные пользователи не являются заинтересованными лицами, так как для них ПО  - инструмент, а не источник дохода
	12. Сам по себе RUP как программный продукт представляет набор связанных гиперссылками страниц HTML, каждая их которых описывает элемент процесса разработки
16. RUP: Фаза «Начало».
	1. Цели
		1. Определить границы/области применения проекта
		2. Описать основные сценарии использования системы
		3. Предложить возможное технологическое решение
		4. Рассчитать стоимость и разработать график работ
		5. Оценить риски
		6. Подготовить окружение
	2. Веха "Lifecycle Objects"
		1. Оценка сроков?
		2. Первоначальная стоимость?
		3. Требования?
		4. Приоритеты?
		5. Технологии?
		6. Оценены риски и выбраны стратегии смягчения последствий?
17. RUP: Фаза «Проектирование».
	1. Цели
		1. Финализировать базовую архитектуру системы
		2. Разработать прототипы на основе архитектуры
		3. Убедиться в том, что архитектура, планы, сроки стабильны, риски разработаны и учтены
	2. Веха "Lifecycle architecture"
		1. Концепция, требования, архитектура проекта стабильны?
		2. Сформированы критерии тестирования прототипов?
		3. Тестирование прототипов показало отсутствие основных рисков?
		4. Планы разработки подробны и приемлимы по цене?
		5. Соотношение запланированных и затраченных расходов приемлимо? 
		6. Стороны подтверждают выполнимость проекта?
18. RUP: Фаза «Построение».
	1. Цели
		1. Экономически эффективно, в максимально короткие сроки реализовать программное обеспечение.
		2. Итеративно провести анализ, проектирование, разработку и тестирование продукта, создать необходимые выпуски (альфа, бета…).
		3. Подготовить продукт, окружение и пользователей к развертыванию.
	2. Веха “Initial Operation Capability”:
		1. Достаточно ли стабилен выпуск для передачи заказчику?
		2. Готова ли принимающая сторона?
		3. Актуальны ли еще расценки на программный продукт?
19. RUP: Фаза «Внедрение».
	1. Цели этой фазы:
		1. Развернуть систему, базу данных на целевой платформе
		2. Обучить пользователей пользоваться продуктом
		3. Запустить маркетинг и продажи, каналы сбыта
		4. Отладить сбои, выкатить хотфиксы и пр.
		5. Убедиться в самодостаточности пользователей
		6. Провести открытый анализ со всеми стейкхолдерами на соответствие программного продукта заявленной концепции
	2. Веха “Release”:
		1. Пользователи удовлетворены?
		2. Финальная стоимость разработки приемлема?
20. Манифест Agile (2001).
	1. Люди и взаимодействие важнее процессов и инструментов
	2. Работающий продукт важнее исчерпывающей документации
	3. Сотрудничнство с заказчиком важнее заключенного согласованного когнтракта
	4. Готовность к изменениям важнее следования первоначальному плану
21. Scrum.
	1. Основной и единственный служебный артефакт скрам - бэклог - упорядоченный по приоритетам список требований с оценкой трудоемкости разработки
	2. Бэклог продукта - более общий и состоящий из бизнес-требований
	3. Бэклог спринта - более детальный, с учетом технических особенностей реализации
	4. Спринт - период времени длиной 1-4 недели
		1. За время спринта разработчики реализуют выбранный набор требований из беклога
		2. Каждый спринт заканчивается демонстрацией проделанной работы заказчику
		3. Через несколько спринтов проводятся ретроспектива (работа над ошибками, перераспределение ролей)
		4. Каждый день во время спринта происходит скрам-митинг (дейлик) утром, где каждый участник команды 
			1. Отчитывается о проделанной работе
			2. Планирование планов к следующей встрече %% fixme: масло масляное %%
	5. Команда состоит из 3-10 людей
	6. Выделяются две особые роли:
		1. Продакт овнер
			1. Определяет порядок разработки требований из бэклога
		2. Скрам-мастер
			1. Ответственен за организацию скрам-митингов
			2. Помогает команде планировать спринты
			3. Следит за внутренними отношениями в команде
	7. Достоинства скрам:
		1. Простота
		2. Минимум административной работы 
		3. Максимальная концентрация на работоспособном коде
22. Disciplined Agile 2.X (2013).
	1. Внебрачный сын RUP и Scrum
	2. Инкрементальная модель разработки опирается на модель спринтов
	3. Что взято из рап:
		1. 3 фазы:
			1. Начало
			2. Построение
			3. Внедрение
		2. Описание каждой роли в разработке
	4. Что взято из скрам:
		1. Спринты
	5. Что придумано уже в DAD:
		1. Управление архитектурой
		2. Переиспользование кода
		3. Управление персоналом
		4. Непрерывное улучшение процессов разработки
23. Требования. Иерархия требований.
	1. Требования - условия или возможности, которым должна соответствовать система
	2. Требование - подробное описание того, что должно быть реализовано
	3. Требование не описывает как его необходимо реализовывать
	4. Требования могут быть общими или подробно описывать то, что должно быть реализовано
	5. Требования описываются в SRS документе (1 лаба опи)
	6. Требования не должны быть разночтенными, иначе это сулит пропажей бабок
	7. Существует иерархия требований:
		1. На вершине - потребности 
			1. Формулирует пользователь
			2. "Мне нужна сковорода, на которой не будет прилипать и пригорать еда"
		2. В середине  - функции
			1. Формулирует аналитик
			2. "Сковорода должна иметь антипригарное покрытие и термоизолирующую ручку"
		3. В основе пирамиды - требования к ПО
			1. "Диаметр сковородки 25см, высота бортиков 5см, сплав пищевого алюминия с кремнием марки АК7П (7% кремния)
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.
41. Системы автоматической сборки: предпосылки появления
42. Системы сборки: Make и Makefile.
43. Системы сборки: Ant. Команды Ant.
44. Системы сборки: Ant-ivy.
45. Системы сборки: Maven. POM. Репозитории и зависимости.
46. Maven: Структура проекта. GAV.
47. Maven: Зависимости. Жизненный цикл сборки. Плагины.
48. Системы сборки: Maven. POM. Репозитории и зависимости.
49. Системы сборки: GNU autotools. Создание конфигурации проекта.50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
50. Сервера сборки/непрерывной интеграции.
51. Основные понятия тестирования. Цели тестирования.
	1. Основные понятния
		1. Mistake -- ошибка разработчика. Человеческое деяние, которое в конечном итоге привело к получению неверного результата. В широком смысле отклонение от истины или правил. 
		2. Fault -- дефект, изъян, Неверный шаг в алгоритме (или неверное определение данных) в компьютерной программе. Следствие ошибки, потенциальная причина неисправности. 
		3. Failure -- неисправность, отказ или сбой -- наблюдаемое проявление дефекта, в том числе, крах или падение программы. невозможность выполнить с использованием программы задачу, получить
		4. Error -- невозможность выполнить с использованием программы задачу, получить верный результат.
	2. Цели тестирования:
		1. Обнаружение дефектов. 
		2. Повышение уверенности в уровне качества. 
		3. Предоставление информации для принятия решений. 
		4. Предотвращение дефектов.
		5. Увеличение **пользовательского** доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах. (то есть мы показываем что ошибки были *найдены и исправлены*)
			- Корректное поведение.
			- Уровень доверия. 
			- Необходимые обстоятельства 
			- Требование реального окружения.
52. Понятие полного тестового покрытия и его достижимости. Пример.
	1. Понятие "тестовое покрытие" включает в себя то, насколько код приложения покрыт тестами, которые могут находить известные и потенциальные дефекты. Полное тестовое покрытие подразумевает покрытие тестами всего кода и всех возможных вариантов развития событий, возможных в данном коде. Полное тестовое покрытие, если и достижимо, то ценой очень больших затрат.
	2. Пример: Умножение двух чисел
		1. В качестве иллюстрации приведена функция умножения двух чисел. Если оба множителя имеют степени $2^{32}$, то для полного покрытия необходимо провести $2^{64}$ операций. Предположим, что 1 операция умножения выполняется за 1 такт процессора. Тогда, учитывая, что $2^{10} \approx 10^3$, однопоточное приложение на 3Гц ЦПУ будет проводить тестирование функции в течение примерно 181,5 лет.
		2. $$
			\frac{2^{32} \cdot 2^{32}}{3 \cdot 10^9} = \frac{2^{10} \cdot 2^{10} \cdot 2^{10} \cdot 2^{34}}{3 \cdot 10^3 \cdot 10^3 \cdot 10^3} \approx \frac{2^{34}}{3} \approx \frac{5723784000}{365 \cdot 24 \cdot 60 \cdot 60} = 181,5 \text{ [лет]}
			$$
53. Статическое и динамическое тестирование.
	1. 
54. Автоматизация тестов и ручное тестирование.
55. Источники данных для тестирования. Роли и деятельности в тестировании.
56. Понятие тестового случая и сценария.
57. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
58. Модульное тестирование. Junit 4.
59. Интеграционное тестирование. Стратегии интеграции.
60. Функциональное тестирование. Selenium.
61. Техники статического тестирования. Статический анализ кода.
62. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
63. Тестирование системы в целом. Альфа- и бета-тестирование.
64. Аспекты быстродействия системы. Влияние средств измерения на результаты.
65. Ключевые характеристики производительности.
66. Нисходящий метод поиска узких мест.
67. Пирамида памяти и ее влияние на производительность.
68. Мониторинг производительности: процессы.
69. Мониторинг производительности: виртуальная память.
70. Мониторинг производительности: буферизированный файловый ввод-вывод.
71. Мониторинг производительности: Windows и Linux.
72. Системный анализ Linux "за 60 секунд".
73. Создание тестовой нагрузки и нагрузчики.
74. Профилирование приложений. Основные подходы.
75. Компромиссы (trade-offs) в производительности.
76. Рецепты повышения производительности при высоком %SYS.
77. Рецепты повышения производительности при высоком %IO wait.
78. Рецепты повышения производительности при высоком %Idle.
79. Рецепты повышения производительности при высоком %User.
