
Что вообще такое смарт-карта?
--
Вообще, изначально смарт-карты впервые начали массово использовать во франции примерно 40 лет назад в качестве карточек для таксофонов (там же монетки раньше использовали, а обмануть такую примитивную систему довольно легко, поэтому злые капиталисты с целью наживи усложнили систему)

Самый первый прототип JCOP был разработан весной 1998, использовались 8-битный микроконтроллер и флеш память. Это был прорыв - теперь можно писать на супер ограниченных микроконтроллерах не на ассемблере, не на Си, а на достаточно высокоуровневой Java

Сейчас же, как утверждает оракл, в 2018 году было примерно выпущено около 6 миллиардов JavaCard-based чипов. Где они все используются? Везде: В телекоме в симкартах, в банковских картах Мастеркард и Виза, для идентификации в госучреждениях (в том числе в паспортах!), в интернете вещей, и даже просто в проездных.

Основные понятия
--

Java Card - версия Java-платформы для устройств с крайне ограниченными вычислительными ресурсами.

JCOP (Java Card OpenPlatform) - ОС для Java Card, разработанная лабораторией IBM расположенной в Цюрихе. Одна из самых распространенных реализаций Java Card. Сочетает в себе открытые стандарты (Java Card API, GlobalPlatform (типа ISO, но для безопасников)). 

JavaCard Virtual Machine - специальная версия JVM, которая работает на JCOP, имеет кучу ограничений, но о них позже

Апплеты (Applets (App + Let(уменьшительный суффикс))) - специальные программы для JCOP. Названы так в соответствии с мидлетами для мобильных устройств и сервлетами для серверов. 

Характеристики Java карты
--
Характеристики для джава карт описывают две важные части: программную и физическую
Физически Java карта обычно миеет
- 8 или 16 битный 3,7 МГц процессор
- 1 Кб ОЗУ
- \>16 Кб Энергонезависимой памяти (EEPROM или флеш-память)

Структура памяти в Java Card
--

| Тип памяти   | Назначение                 |
| ------------ | -------------------------- |
| ПЗУ (ROM)    | Код JCOP и VM              |
| EEPROM/Flash | Апплеты и данные           |
| ОЗУ (RAM)    | Стек, локальные переменные |
Данные по умолчанию хранятся в энергонезависимой памяти (EEPROM/Flash), тогда как оперативная RAM содержит небольшую кучу (a.k.a. heap) и стек, используется только для временных (a.k.a. транзиентных) объектов


А программная спецификация как выглядит?
--
Программно же Java карта имеет следующие спецификации:
- Спецификацию виртуальной машины
- Спецификацию среды выполнения Java Card
- Спецификацию API Java Card
Все это в себя включает Java Card Dev Kit (который нормально через хоумбрю или апт не скачать, только с сайта оракл имея не российский аккаунт))))

А чем вообще отличается классическая Java Standart Edition от микро-jvm для смарткарт?
--
На уровне языка - особо ничем. Синтаксис тот же,  ифы, циклы, объявления, свитчкейсы - все как и в жаве, компилируется в .class самым обычным javac'ом без лишних флажков. Но есть некоторые отличия, которые ограничивают возможности, и вот некоторые вещи, которые не доступны в микрожвм: 
- Динамическая загрузка классов
- Потоки
- Клонирование объектов
- Рекурсия (а кому она в стандартной жаве то нужна была.....)
- Ключевые слова synchronized, transient
- Самое главное: многие привычные типы данных отсутствуют, например chat, double, float, long, многомерные массивы, а int опционален (используй тока short и byte)
- java.io, java.lang, java.util мой любимый, тоже порезали 
- Исключения вообще подчистую, пиши сразу без ошибок
Плюс есть некие ограничения в самой структуре пакетов (тут не все):
- Название пакета - максимум 255 байт
- Класс реализует максимум 15 интерфейсов
- Пакет может иметь только 256 статических методов
- Класс может иметь максимум 128 методов
А еще может отсутствовать сборщик мусора, поэтому don't litter пж, создал один раз объект, так им и пользуйся

А как вообще апплеты выглядят?
--

Апплеты пишутся в обычном .java файле. Код представляет из себя экземпляр класса, унаследованного от некоторого абстрактного класса JavaCard API, методы которого обеспечивают базовый функционал (например, обработку установки, реакцию на команды от компьютера). Все члены класса апплета являются персистентными и хранятся в EEPROM (Electrically Erasable Programmable Read-Only Memory, вид стираемого перепрограммироемого постоянного запоминающего устройства)

APDU (application protocol data unit) — это формат общения карты и терминала. Терминал посылает Command APDU (C-APDU), а карта отвечает с Response APDU (R-APDU).

https://habr.com/ru/articles/255529/
https://habr.com/ru/articles/255529/

```Java
package org.gitian.javacard;

import javacard.framework.APDU;
import javacard.framework.Applet;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacard.framework.Util;

public class HelloWorldApplet extends Applet {
    private static final byte[] helloWorld = {'H', 'e', 'l', 'l', 'o'};
    private static final byte HW_CLA = (byte) 0x80;
    private static final byte HW_INS = (byte) 0x00;

    public static void install(byte[] bArray, short bOffset, byte bLength) {
        new HelloWorldApplet().register(bArray, (short) (bOffset + 1), bArray[bOffset]);
    }

    public void process(APDU apdu) {
        if (selectingApplet()) {
            return;
        }

        byte[] buffer = apdu.getBuffer();
        byte CLA = buffer[ISO7816.OFFSET_CLA];
        byte INS = buffer[ISO7816.OFFSET_INS];

        if (CLA != HW_CLA) {
            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);
        }

        if (INS == HW_INS) {
            getHelloWorld(apdu);
        } else {
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }
    }

    private void getHelloWorld(APDU apdu) {
        byte[] buffer = apdu.getBuffer();
        short length = (short) helloWorld.length;
        Util.arrayCopyNonAtomic(helloWorld, (short) 0, buffer, (short) 0, length);
        apdu.setOutgoingAndSend((short) 0, length);
    }
}
```

```Java
package at.ac.tuwien.mnsa.javacard;

import javacard.framework.APDU;
import javacard.framework.Applet;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;

public class Calculator extends Applet {

	private static final byte ADD = (byte) 0x01;
	private static final byte SUB = (byte) 0x02;
	private static final byte MUL = (byte) 0x03;
	private static final byte DIV = (byte) 0x04;
	private static final byte AND = (byte) 0x05;
	private static final byte OR = (byte) 0x06;
	private static final byte NOT = (byte) 0x07;

	private Calculator() {
		register();
	}

	public static void install(byte[] bArray, short bOffset, byte bLength) {
		new Calculator();
	}

	public void process(APDU apdu) throws ISOException {
		if (selectingApplet()) {
			return;
		}

		byte[] buffer = apdu.getBuffer();
		if (buffer[ISO7816.OFFSET_CLA] != 0x00) {
			ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);
		}

		byte p1 = buffer[ISO7816.OFFSET_P1];
		byte p2 = buffer[ISO7816.OFFSET_P2];
		short result = 0;

		switch (buffer[ISO7816.OFFSET_INS]) {
			case ADD:
				result = (short) (p1 + p2);
				break;
			case SUB:
				result = (short) (p1 - p2);
				break;
			case MUL:
				result = (short) (p1 * p2);
				break;
			case AND:
				result = (short) (p1 & p2);
				break;
			case OR:
				result = (short) (p1 | p2);
				break;
			case NOT:
				if (p2 != 0x00) {
					ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);
				}
				result = (short) ~p1;
				break;
			default:
				ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
		}

		buffer[0] = (byte) (result & 0xff);
		buffer[1] = (byte) (result >>> 8);

		apdu.setOutgoingAndSend((short) 0, (short) 2);
	}
}
```


Ну вот код написан да, а дальше что делать??
--
В Java Card программы исполняются немного нетрадиционно
Как бы да, мы javac'ом переходим от .java к .class, но на джава карте недостаточно мощностей для just-in-time компиляции. Поэтому, чтобы запустить свой апплет, необходимо
1) Сконвертировать .class файлы в .cap (converted applet), который содержит все классы в пакете Java в загружаемом исполняемом двоичном представлении
2) А после этого уже перекидываем по юсб переходнику бинарники на карточку


Ну вот закинули да, а как оно под капотом то работает??
--
![[Pasted image 20250524211300.png]]
Срок службы JCVM (Java Card Virtual Machine) совпадает со сроком службы самой карты, то есть он начинается в момент изготовления и тестирования карты и заканчивается, когда карта выбрасывается или уничтожается. 
JCRE (Java Card Runtime Environment) инициализируется при старте JCVM, и создает все объекты фреймфорка JCRE, которые существуют в течение всего срока службы JCVM.
После запуска JCVM в принципе все взаимодействия с картой контролируются апплетами на карте. При отключении питания все данные, содержащиеся в ОЗУ теряются, но любое состояние, сохраненное в EEPROM/Флэш памяти сохраняется. При повторном включении питания виртуальная машина снвоа возобновляет свою работу, все объекты восстанавливаются и выполнение возобновляется в ожидадании дальнейшего ввода.


Ну это круто да, а что насчет жизненного цикла? Как там байтики перекладываются?
--

Каждый апплет идентифицируется идентификатором приложения (AID). AID представляет собой последовательность от 5 до 16 байтов (Именно такие числа потому что так определенно в ISO 7816-5)
Каждый апплет должен расширять абстрактный класс `Applet`, который определяет методы, используемые JCRE для управления жизненным циклом апплета
![[Pasted image 20250524212706.png]]

Собственно сам жизненный цикл апплета:
- Начинается когда апплет загружается на карту
- У него вызывается метод register
- Он ждет пока его выберут
- Он чето делает там логику свою
- Дезактивируется

А вот многопоточки нет, а если я все таки хочу много всего одновременно использовать?
--
Ну ладно, есть каналы. Можно открывать до 16 сеансов приложений на смарт-карте одновременно, по одному сеансу на логический канал
Можно еще сделать чтобы какой то канал стал дефолтным


Ок, это все понятно, круто. Но вот 256 байт оперативки и пара килобайт постоянной памяти - разве это серьезно? Реально разве как то что то сделать нормальное?
--
Краткий ответ - реально. В 1977 году Вояджеры исследовать Сатурн отправляли имея 68кб оперативки, а вы тут чето разнылись насчет ключ-карты в офис, лол.

Более долгий ответ:
 1. Как говорилось раньше, у нас используются только byte'ы и short'ы, а не int'ы всякие
2. Надо прям учитывать существует ли Garbage Collector на карте под которую мы пишем код, или нет, ведь если нет - то **любой** объект, который мы создадим с помощью оператора new останется висеть в памяти просто навечно (поэтому его надо использовать с умом, и в идеале только при первом запуске апплета). Уничтожить, освободить его - просто невозможно, единственный путь - это удалить апплет и написать нормальный код
3. Если нам все же надо работать с каким-то объектом, который часто обновляется, то нам надо использовать такую концепцию как "временные" объекты. Ключевое слово transient в JCOP отсутствует, и надо как то выкручиваться. Для этого есть следующие методы:
```Java
static byte[] makeTransientByteArray(short length, byte event)
static Object makeTransientObjectArray(short length, byte event)
static short[] makeTransientShortArray(short length, byte event)
static byte isTransient(java.lang.Object theObj)
```
1. Но даже если GC присутствует, то надо учитывать что автоматически в большинстве случаев просто не будет, и придется вызывать его вручную, а это не очень хорошо потому что:
	1. Это просто напросто долго
	2. Происходит фрагментация памяти, то есть хоть память и освобождается, но из-за того что у нас пояляется много маленьких несмежных блоков, то это делает ее просто недоступной
	3. А дефрагментация это супер отстой, потому что на EEROM это супер долгий процесс
2. Кстати, насчет фрагментации
	1. Апплеты в памяти карты - это по сути тоже самое, что и файл на жестком диске, то есть если удалить апплет, который расположен перед другим, то в памяти останется пустое пространство размером с удаленный апплет
	2. Чтобы избежать фрагментации в данном случае, надо следовать двум простым правилам:
		1. Если у нас есть апплет, который надо удалить/обновить, и он находится между другими апплетами, то перед его удалением надо соответственно удалить все послеидущие апплеты и заново их загрузить после обновления
		2. Если некоторые апплеты после записи в карту удалять не продполагается, надо записывать их первыми
3. Оперативка как бы есть, да, она быстрая (явно быстрее EEROM), и можно выделить ее с помощью вызова Util.makeTransientArray, но надо учитывать что оперативка общая для всех апплетов, и если не учитывать остальные апплеты, то можно попасть в неприятную ситуацию когда память может просто не выделится


Безопасность в JCOP
--
Первое, и самое на мой взгляд важное - это изоляция апплетов, который можно назвать брандмауром/файрволом
В чем вообще суть: каждое приложение работает в собственном защищенном контексте и с собственной виртуальной кучей. Это предотвращает доступ одного апплета к данным другого без явного разрешения
![[Pasted image 20250526180849.png]]

Второе - это аппаратная криптография. То есть в этой маленькой карточке установлен маленький аналоговой ускоритель криптографических алгоритмов, таких как например AES, RSA (зависит от реализации). Это не только ускоряет операции, но и защищает от атак, направленных на программные реализации криптографии.

Третье, это то, что карты сертифицированы по стандарту Common Criteria EAL5+, что означает наличие защиты от физических атак, такиъ как анализ потребления энергии и попытки вмешательства в работу карты

Четвертое - это защита памяти и транзакций. Все данные по умолчанию хранятся в энергонезависимой памяти, а операции записи выполняются атомарно

Все эти факты делают Java Card этаким черным ящиком, на который если загрузить какой то код - то достать его никак нельзя будет, и в теории можно это дополнительно защитить всякими механизмами по типу "если было произведено 3 неудачные попытки входа, то карта блокируется", и достать данные уже никак нельзя будет на практике




Краткое описание для согласования темы:
[[[
JCOP: как запустить java на 256 байтах RAM?

JCOP (Java Card OpenPlatform) — это операционная система на основе Java Card, разработанная IBM и NXP для смарт-карт с крайне ограниченными ресурсами (например, 256 байт RAM). Платформа позволяет запускать защищённые приложения (applet) в условиях строгих ограничений памяти и производительности. В докладе будут рассмотрены архитектурные особенности JCOP, методы оптимизации Java-кода для работы в микроконтроллерах, а также её роль в обеспечении безопасности в устройствах, таких как ключи Tesla Model 3, банковские карты и транспортные билеты.

Полезное для слушателей:

1. Понимание архитектуры Java Card: принципы компиляции и исполнения Java-байткода на микроконтроллерах с минимальной памятью.
2. Методы оптимизации: применение фиксированных буферов, ограничение динамического выделения памяти и использование статической типизации для снижения накладных расходов.
3. Безопасность в JCOP: механизмы изоляции applet-приложений, защита ключей шифрования и интеграция с протоколами PKI (на примере Tesla Model 3).
4. Практическая польза: применение подходов JCOP в IoT-устройствах и embedded-системах с ограниченными ресурсами.

Источники информации
https://public.dhe.ibm.com/software/pervasive/info/JCOP_Family.pdf
https://github.com/darconeous/gauss-key-card?tab=readme-ov-file
https://gist.github.com/darconeous/2cd2de11148e3a75685940158bddf933
https://www.oracle.com/java/java-card/
]]]
